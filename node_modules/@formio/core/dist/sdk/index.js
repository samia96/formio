/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(self, function() {
return /******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@formio/lodash/lib/array.js":
/*!**************************************************!*\
  !*** ./node_modules/@formio/lodash/lib/array.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.intersection = exports.map = exports.head = exports.last = exports.filter = exports.findEach = exports.matches = exports.findIndex = exports.find = exports.each = exports.dropRight = exports.drop = exports.difference = exports.concat = exports.compact = exports.chunk = void 0;\nvar lang_1 = __webpack_require__(/*! ./lang */ \"./node_modules/@formio/lodash/lib/lang.js\");\nvar object_1 = __webpack_require__(/*! ./object */ \"./node_modules/@formio/lodash/lib/object.js\");\n// https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_chunk\nfunction chunk(input, size) {\n    return input.reduce(function (arr, item, idx) {\n        return idx % size === 0\n            ? __spreadArray(__spreadArray([], arr, true), [[item]], false) : __spreadArray(__spreadArray([], arr.slice(0, -1), true), [__spreadArray(__spreadArray([], arr.slice(-1)[0], true), [item], false)], false);\n    }, []);\n}\nexports.chunk = chunk;\n;\n// https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_compact\nfunction compact(input) {\n    return input.filter(Boolean);\n}\nexports.compact = compact;\n/**\n * @link https://lodash.com/docs/4.17.15#concat\n * @param input\n * @param args\n * @returns\n */\nfunction concat(input) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    return input.concat.apply(input, args);\n}\nexports.concat = concat;\n// https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_difference\nfunction difference() {\n    var arrays = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        arrays[_i] = arguments[_i];\n    }\n    return arrays.reduce(function (a, b) {\n        return a.filter(function (value) {\n            return !b.includes(value);\n        });\n    });\n}\nexports.difference = difference;\n// https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_drop\nfunction drop(arr, index) {\n    if (index === void 0) { index = 1; }\n    return (index > 0) ? arr.slice(index) : arr;\n}\nexports.drop = drop;\n// https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_dropright\nfunction dropRight(arr, index) {\n    if (index === void 0) { index = 1; }\n    return (index > 0) ? arr.slice(0, -index) : arr;\n}\nexports.dropRight = dropRight;\n/**\n * Iterate through a collection or array.\n * @param collection\n * @param _each\n */\nfunction each(collection, _each) {\n    var isArray = Array.isArray(collection);\n    for (var i in collection) {\n        if (collection.hasOwnProperty(i)) {\n            if (_each(collection[i], isArray ? Number(i) : i) === true) {\n                break;\n            }\n            ;\n        }\n    }\n}\nexports.each = each;\n/**\n * Perform a find operation.\n * @param arr\n * @param query\n */\nfunction find(arr, query, findIndex) {\n    if (findIndex === void 0) { findIndex = false; }\n    if (!arr) {\n        return undefined;\n    }\n    if (Array.isArray(arr) && typeof query === 'function') {\n        return findIndex ? arr.findIndex(query) : arr.find(query);\n    }\n    var found = undefined;\n    var foundIndex = 0;\n    findEach(arr, query, function (item, index) {\n        found = item;\n        foundIndex = index;\n        return true;\n    });\n    return findIndex ? foundIndex : found;\n}\nexports.find = find;\n/**\n * Find an index.\n *\n * @param arr\n * @param query\n * @returns\n */\nfunction findIndex(arr, query) {\n    return find(arr, query, true);\n}\nexports.findIndex = findIndex;\n/**\n * Returns a function to perform matches.\n * @param query\n * @returns\n */\nfunction matches(query) {\n    var keys = [];\n    var compare = {};\n    if (typeof query === 'string') {\n        keys = [query];\n        compare[query] = true;\n    }\n    else {\n        keys = Object.keys(query);\n        compare = query;\n    }\n    return function (comp) {\n        return (0, lang_1.isEqual)((0, object_1.pick)(comp, keys), compare);\n    };\n}\nexports.matches = matches;\n/**\n * Perform a find operation on each item in an array.\n * @param arr\n * @param query\n * @param fn\n */\nfunction findEach(arr, query, fn) {\n    each(arr, function (item, index) {\n        if (matches(query)(item)) {\n            if (fn(item, index) === true) {\n                return true;\n            }\n        }\n    });\n}\nexports.findEach = findEach;\n/**\n * Perform a filter operation.\n * @param arr\n * @param fn\n */\nfunction filter(arr, fn) {\n    if (!arr) {\n        return [];\n    }\n    if (!fn) {\n        fn = function (val) { return !!val; };\n    }\n    if (Array.isArray(arr) && typeof fn === 'function') {\n        return arr.filter(fn);\n    }\n    var found = [];\n    findEach(arr, fn, function (item, index) {\n        found.push(item);\n        if (Array.isArray(item)) {\n            arr.splice(index, 1);\n        }\n        else {\n            delete arr[index];\n        }\n    });\n    return found;\n}\nexports.filter = filter;\n/**\n * Get the last item in an array.\n * @param arr\n */\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\nexports.last = last;\n/**\n * https://lodash.com/docs/4.17.15#head\n * @param arr\n * @returns\n */\nfunction head(arr) {\n    return arr[0];\n}\nexports.head = head;\n/**\n * https://lodash.com/docs/4.17.15#map\n * @param arr\n * @param fn\n * @returns\n */\nfunction map(arr, fn) {\n    return arr.map(fn);\n}\nexports.map = map;\n/**\n * Get the intersection of two objects.\n * @param a\n * @param b\n */\nfunction intersection(a, b) {\n    return a.filter(function (value) { return b.includes(value); });\n}\nexports.intersection = intersection;\n\n\n//# sourceURL=webpack://@formio/core/./node_modules/@formio/lodash/lib/array.js?");

/***/ }),

/***/ "./node_modules/@formio/lodash/lib/function.js":
/*!*****************************************************!*\
  !*** ./node_modules/@formio/lodash/lib/function.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.debounce = void 0;\n/**\n * Debounc the call of a function for a given amount of time.\n *\n * @param func\n * @param wait\n * @returns\n */\nfunction debounce(func, wait) {\n    if (wait === void 0) { wait = 100; }\n    var timeout;\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (timeout) {\n            clearTimeout(timeout);\n        }\n        timeout = setTimeout(function () {\n            timeout = null;\n            func.apply(void 0, args);\n        }, wait);\n    };\n}\nexports.debounce = debounce;\n\n\n//# sourceURL=webpack://@formio/core/./node_modules/@formio/lodash/lib/function.js?");

/***/ }),

/***/ "./node_modules/@formio/lodash/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@formio/lodash/lib/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.chain = void 0;\nvar ArrayFunctions = __importStar(__webpack_require__(/*! ./array */ \"./node_modules/@formio/lodash/lib/array.js\"));\nvar Chainable = /** @class */ (function () {\n    function Chainable(val) {\n        this.chain = [];\n        this.currentValue = [];\n        this.currentValue = val;\n    }\n    Chainable.prototype.value = function () {\n        return this.chain.reduce(function (current, func) {\n            var _a;\n            return (_a = ArrayFunctions)[func.method].apply(_a, __spreadArray([current], func.args, false));\n        }, this.currentValue);\n    };\n    return Chainable;\n}());\nvar _loop_1 = function (method) {\n    if (ArrayFunctions.hasOwnProperty(method)) {\n        Chainable.prototype[method] = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            this.chain.push({ method: method, args: args });\n            return this;\n        };\n    }\n};\nfor (var method in ArrayFunctions) {\n    _loop_1(method);\n}\n/**\n * Create a chainable array of methods.\n * @param val\n * @returns\n */\nfunction chain(val) {\n    return new Chainable(val);\n}\nexports.chain = chain;\nexports[\"default\"] = chain;\n__exportStar(__webpack_require__(/*! ./array */ \"./node_modules/@formio/lodash/lib/array.js\"), exports);\n__exportStar(__webpack_require__(/*! ./function */ \"./node_modules/@formio/lodash/lib/function.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lang */ \"./node_modules/@formio/lodash/lib/lang.js\"), exports);\n__exportStar(__webpack_require__(/*! ./math */ \"./node_modules/@formio/lodash/lib/math.js\"), exports);\n__exportStar(__webpack_require__(/*! ./object */ \"./node_modules/@formio/lodash/lib/object.js\"), exports);\n__exportStar(__webpack_require__(/*! ./string */ \"./node_modules/@formio/lodash/lib/string.js\"), exports);\n\n\n//# sourceURL=webpack://@formio/core/./node_modules/@formio/lodash/lib/index.js?");

/***/ }),

/***/ "./node_modules/@formio/lodash/lib/lang.js":
/*!*************************************************!*\
  !*** ./node_modules/@formio/lodash/lib/lang.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isRegExp = exports.isBoolean = exports.isNumber = exports.isPlainObject = exports.isObject = exports.isObjectLike = exports.isArray = exports.isNull = exports.isNil = exports.isNaN = exports.isInteger = exports.isEmpty = exports.isString = exports.isEqual = exports.noop = void 0;\nvar array_1 = __webpack_require__(/*! ./array */ \"./node_modules/@formio/lodash/lib/array.js\");\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction getTag(value) {\n    if (value == null) {\n        return value === undefined ? '[object Undefined]' : '[object Null]';\n    }\n    return Object.prototype.toString.call(value);\n}\n/**\n * A no-operation function.\n */\nfunction noop() {\n    return;\n}\nexports.noop = noop;\n;\n/**\n * Determines equality of a value or complex object.\n * @param a\n * @param b\n */\nfunction isEqual(a, b) {\n    var equal = false;\n    if (a === b) {\n        return true;\n    }\n    if (a && b && (Array.isArray(a) || isObject(a)) && Object.keys(a).length === Object.keys(b).length) {\n        equal = true;\n        (0, array_1.each)(a, function (val, key) {\n            if ((Array.isArray(val) || isObject(val)) && !isEqual(b[key], val)) {\n                equal = false;\n                return true;\n            }\n            if (b[key] !== val) {\n                equal = false;\n                return true;\n            }\n        });\n    }\n    return equal;\n}\nexports.isEqual = isEqual;\nfunction isString(val) {\n    return typeof val === 'string';\n}\nexports.isString = isString;\n// https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_isempty\nfunction isEmpty(val) {\n    return [Object, Array].includes((val || {}).constructor) && !Object.entries((val || {})).length;\n}\nexports.isEmpty = isEmpty;\nfunction isInteger(val) {\n    return Number.isInteger(val);\n}\nexports.isInteger = isInteger;\nfunction isNaN(val) {\n    return Number.isNaN(val);\n}\nexports.isNaN = isNaN;\nfunction isNil(val) {\n    return val == null;\n}\nexports.isNil = isNil;\nfunction isNull(val) {\n    return val === null;\n}\nexports.isNull = isNull;\nfunction isArray(val) {\n    return Array.isArray(val);\n}\nexports.isArray = isArray;\nfunction isObjectLike(val) {\n    return typeof val === 'object' && (val !== null);\n}\nexports.isObjectLike = isObjectLike;\nfunction isObject(val) {\n    var type = typeof val;\n    return val != null && (type === 'object' || type === 'function');\n}\nexports.isObject = isObject;\nfunction isPlainObject(value) {\n    if (!isObjectLike(value) || getTag(value) != '[object Object]') {\n        return false;\n    }\n    if (Object.getPrototypeOf(value) === null) {\n        return true;\n    }\n    var proto = value;\n    while (Object.getPrototypeOf(proto) !== null) {\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(value) === proto;\n}\nexports.isPlainObject = isPlainObject;\nfunction isNumber(val) {\n    return typeof val === 'number' || (isObjectLike(val) && getTag(val) == '[object Number]');\n}\nexports.isNumber = isNumber;\nfunction isBoolean(val) {\n    return val === true || val === false || (isObjectLike(val) && getTag(val) == '[object Boolean]');\n}\nexports.isBoolean = isBoolean;\nfunction isRegExp(val) {\n    return isObjectLike(val) && getTag(val) == '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\n\n//# sourceURL=webpack://@formio/core/./node_modules/@formio/lodash/lib/lang.js?");

/***/ }),

/***/ "./node_modules/@formio/lodash/lib/math.js":
/*!*************************************************!*\
  !*** ./node_modules/@formio/lodash/lib/math.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.sumBy = exports.sum = exports.mod = exports.subtract = exports.round = exports.multiply = exports.minBy = exports.min = exports.meanBy = exports.mean = exports.maxBy = exports.max = exports.floor = exports.divide = exports.ceil = exports.add = void 0;\nvar lang_1 = __webpack_require__(/*! ./lang */ \"./node_modules/@formio/lodash/lib/lang.js\");\nvar object_1 = __webpack_require__(/*! ./object */ \"./node_modules/@formio/lodash/lib/object.js\");\nfunction mathOp(a, op, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (!precision) {\n        return op(a);\n    }\n    precision = Math.pow(10, precision);\n    return op(a * precision) / precision;\n}\nfunction compareBy(arr, fn, op) {\n    var first = arr[0];\n    if (arr.length <= 1) {\n        return first;\n    }\n    var fnString = (0, lang_1.isString)(fn);\n    return arr.slice(1).reduce(function (current, next) {\n        var currentValue = fnString ? (0, object_1.get)(current, fn) : fn(current);\n        var nextValue = fnString ? (0, object_1.get)(next, fn) : fn(next);\n        var result = op(currentValue, nextValue);\n        return (result === nextValue) ? next : current;\n    }, first);\n}\nfunction valueBy(arr, fn, op) {\n    var first = arr[0];\n    if (arr.length <= 1) {\n        return first;\n    }\n    var fnString = (0, lang_1.isString)(fn);\n    return arr.slice(1).reduce(function (current, next) { return op(current, fnString ? (0, object_1.get)(next, fn) : fn(next)); }, fnString ? (0, object_1.get)(first, fn) : fn(first));\n}\n/**\n * @link https://lodash.com/docs/4.17.15#add\n * @param augend\n * @param addend\n * @returns\n */\nfunction add(augend, addend) {\n    return augend + addend;\n}\nexports.add = add;\n/**\n * @link https://lodash.com/docs/4.17.15#ceil\n * @param num\n * @param precision\n * @returns\n */\nfunction ceil(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    return mathOp(num, Math.ceil, precision);\n}\nexports.ceil = ceil;\n/**\n * https://lodash.com/docs/4.17.15#divide\n * @param dividend\n * @param divisor\n * @returns\n */\nfunction divide(dividend, divisor) {\n    return dividend / divisor;\n}\nexports.divide = divide;\n/**\n * @link https://lodash.com/docs/4.17.15#floor\n * @param num\n * @param precision\n * @returns\n */\nfunction floor(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    return mathOp(num, Math.floor, precision);\n}\nexports.floor = floor;\n/**\n * @link https://lodash.com/docs/4.17.15#max\n * @param arr\n * @returns\n */\nfunction max(arr) {\n    return Math.max.apply(Math, arr);\n}\nexports.max = max;\n/**\n * @link https://lodash.com/docs/4.17.15#maxBy\n */\nfunction maxBy(arr, fn) {\n    return compareBy(arr, fn, Math.max);\n}\nexports.maxBy = maxBy;\n/**\n * @link https://lodash.com/docs/4.17.15#mean\n * @param arr\n * @returns\n */\nfunction mean(arr) {\n    return sum(arr) / arr.length;\n}\nexports.mean = mean;\n/**\n * @link https://lodash.com/docs/4.17.15#meanBy\n * @param arr\n * @param fn\n * @returns\n */\nfunction meanBy(arr, fn) {\n    return sumBy(arr, fn) / arr.length;\n}\nexports.meanBy = meanBy;\n/**\n * @link https://lodash.com/docs/4.17.15#min\n * @param arr\n * @returns\n */\nfunction min(arr) {\n    return Math.min.apply(Math, arr);\n}\nexports.min = min;\n/**\n * @link https://lodash.com/docs/4.17.15#minBy\n * @param arr\n * @param fn\n * @returns\n */\nfunction minBy(arr, fn) {\n    return compareBy(arr, fn, Math.min);\n}\nexports.minBy = minBy;\n/**\n * @link https://lodash.com/docs/4.17.15#multiply\n * @param multiplier\n * @param multiplicand\n * @returns\n */\nfunction multiply(multiplier, multiplicand) {\n    return multiplier * multiplicand;\n}\nexports.multiply = multiply;\n/**\n * @link https://lodash.com/docs/4.17.15#round\n * @param num\n * @param precision\n * @returns\n */\nfunction round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    return mathOp(num, Math.round, precision);\n}\nexports.round = round;\n/**\n * @link https://lodash.com/docs/4.17.15#subtract\n * @param a\n * @param b\n * @returns\n */\nfunction subtract(minuend, subtrahend) {\n    return minuend - subtrahend;\n}\nexports.subtract = subtract;\n/**\n * Perform a modulus operation between two numbers.\n * @param a\n * @param b\n * @returns\n */\nfunction mod(a, b) {\n    return a % b;\n}\nexports.mod = mod;\n/**\n * @link https://lodash.com/docs/4.17.15#sum\n * @param arr\n * @returns\n */\nfunction sum(arr) {\n    return arr.reduce(add, 0);\n}\nexports.sum = sum;\n/**\n * @link https://lodash.com/docs/4.17.15#sumBy\n * @param arr\n * @param fn\n * @returns\n */\nfunction sumBy(arr, fn) {\n    return valueBy(arr, fn, function (a, b) { return (a + b); });\n}\nexports.sumBy = sumBy;\n\n\n//# sourceURL=webpack://@formio/core/./node_modules/@formio/lodash/lib/math.js?");

/***/ }),

/***/ "./node_modules/@formio/lodash/lib/object.js":
/*!***************************************************!*\
  !*** ./node_modules/@formio/lodash/lib/object.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.pick = exports.defaults = exports.cloneDeep = exports.clone = exports.fastCloneDeep = exports.merge = exports.set = exports.has = exports.propertyOf = exports.property = exports.get = exports.pathParts = exports.values = exports.keys = void 0;\nvar lang_1 = __webpack_require__(/*! ./lang */ \"./node_modules/@formio/lodash/lib/lang.js\");\nvar array_1 = __webpack_require__(/*! ./array */ \"./node_modules/@formio/lodash/lib/array.js\");\n/**\n * Get the keys of an Object.\n * @param obj\n */\nfunction keys(obj) {\n    return Object.keys(obj);\n}\nexports.keys = keys;\n;\n/**\n * Return the values of an object or an array.\n * @param obj\n * @returns\n */\nfunction values(obj) {\n    return (0, lang_1.isArray)(obj) ? obj : Object.values(obj);\n}\nexports.values = values;\n/**\n * Retrieve the path parts provided a path string.\n * @param path\n */\nfunction pathParts(path) {\n    if (!path) {\n        return [];\n    }\n    if (path[0] === '[') {\n        path = path.replace(/^\\[([^\\]]+)\\]/, '$1');\n    }\n    return path.\n        replace(/\\[/g, '.').\n        replace(/\\]/g, '').\n        split('.');\n}\nexports.pathParts = pathParts;\n/**\n * Get the value from an object or an array provided a path.\n *\n * @param obj\n * @param path\n * @param def\n */\nfunction get(obj, path, def) {\n    var val = pathParts(path).reduce(function (o, k) { return (o || {})[k]; }, obj);\n    return (typeof def !== 'undefined' &&\n        typeof val === 'undefined') ? def : val;\n}\nexports.get = get;\nfunction property(path) {\n    return function (obj) { return get(obj, path); };\n}\nexports.property = property;\nfunction propertyOf(obj) {\n    return function (path) { return get(obj, path); };\n}\nexports.propertyOf = propertyOf;\n/**\n * Determine if a value is set.\n *\n * @param obj\n * @param path\n */\nfunction has(obj, path) {\n    return get(obj, path, undefined) !== undefined;\n}\nexports.has = has;\n/**\n * Sets the value of an item within an array or object.\n * @param obj\n * @param path\n * @param value\n */\nfunction set(obj, path, value) {\n    var parts = pathParts(path);\n    parts.reduce(function (o, k, i) {\n        if (!isNaN(Number(k))) {\n            k = Number(k);\n        }\n        if ((Array.isArray(o) ? (k >= o.length) : !o.hasOwnProperty(k)) ||\n            ((i < (parts.length - 1)) && !Array.isArray(o[k]) && !(0, lang_1.isObject)(o[k]))) {\n            o[k] = !isNaN(Number(parts[i + 1])) ? [] : {};\n        }\n        if (i === (parts.length - 1)) {\n            o[k] = value;\n        }\n        return o[k];\n    }, obj);\n    return obj;\n}\nexports.set = set;\n;\nfunction propertyIsOnObject(object, property) {\n    try {\n        return property in object;\n    }\n    catch (_) {\n        return false;\n    }\n}\n// Protects from prototype poisoning and unexpected merging up the prototype chain.\nfunction propertyIsUnsafe(target, key) {\n    return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n        && !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n            && Object.propertyIsEnumerable.call(target, key)); // and also unsafe if they're nonenumerable.\n}\n/**\n * Merge a single object.\n *\n * @param target\n * @param source\n * @returns\n */\nfunction mergeObject(target, source) {\n    for (var key in source) {\n        if (source.hasOwnProperty(key)) {\n            if (propertyIsUnsafe(target, key)) {\n                return;\n            }\n            if (propertyIsOnObject(target, key)) {\n                target[key] = merge(target[key], source[key]);\n            }\n            else {\n                target[key] = cloneDeep(source[key]);\n            }\n        }\n    }\n    return target;\n}\n/**\n * Merge two arrays.\n * @param target\n * @param source\n */\nfunction mergeArray(target, source) {\n    source.forEach(function (subSource, index) {\n        target[index] = merge(target[index], subSource);\n    });\n    return target;\n}\n/**\n * Merges a complex data object.\n *\n * @param a\n * @param b\n * @param options\n */\nfunction merge() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var first = args.shift();\n    return args.reduce(function (target, source, index) {\n        if (!target || (target === source)) {\n            return cloneDeep(source);\n        }\n        else if ((0, lang_1.isArray)(source)) {\n            // If there is no target array, then make it one.\n            if (!(0, lang_1.isArray)(target)) {\n                args[index] = target = [];\n            }\n            return mergeArray(target, source);\n        }\n        else if ((0, lang_1.isPlainObject)(source)) {\n            return mergeObject(target, source);\n        }\n        else {\n            return cloneDeep(source);\n        }\n    }, first);\n}\nexports.merge = merge;\n/**\n * Performs a fast clone deep operation.\n *\n * @param obj\n */\nfunction fastCloneDeep(obj) {\n    try {\n        return JSON.parse(JSON.stringify(obj));\n    }\n    catch (err) {\n        console.log(\"Clone Failed: \".concat(err.message));\n        return null;\n    }\n}\nexports.fastCloneDeep = fastCloneDeep;\n/**\n * Performs a shallow clone of an object.\n * @param src\n */\nfunction clone(src) {\n    if (Array.isArray(src)) { // for arrays\n        return __spreadArray([], src, true);\n    }\n    else {\n        return __assign({}, src);\n    }\n}\nexports.clone = clone;\n/**\n * Performs a recursive cloneDeep operation.\n * @param src\n * @returns\n */\nfunction cloneDeep(src) {\n    if (Array.isArray(src)) { // for arrays\n        return src.map(cloneDeep);\n    }\n    if (src === null || typeof src !== 'object') { // for primitives / functions / non-references/pointers\n        return src;\n    }\n    return Object.fromEntries(Object.entries(src).map(function (_a) {\n        var key = _a[0], val = _a[1];\n        return ([key, cloneDeep(val)]);\n    }));\n}\nexports.cloneDeep = cloneDeep;\n/**\n * Sets the defaults of an object.\n *\n * @param obj\n * @param defs\n */\nfunction defaults(obj, defs) {\n    (0, array_1.each)(defs, function (value, key) {\n        if (!obj.hasOwnProperty(key)) {\n            obj[key] = value;\n        }\n    });\n    return obj;\n}\nexports.defaults = defaults;\n/**\n * Pick an item in an object.\n * @param object\n * @param keys\n */\nfunction pick(object, keys) {\n    return keys.reduce(function (obj, key) {\n        if (object && object.hasOwnProperty(key)) {\n            obj[key] = object[key];\n        }\n        return obj;\n    }, {});\n}\nexports.pick = pick;\n;\n\n\n//# sourceURL=webpack://@formio/core/./node_modules/@formio/lodash/lib/object.js?");

/***/ }),

/***/ "./node_modules/@formio/lodash/lib/string.js":
/*!***************************************************!*\
  !*** ./node_modules/@formio/lodash/lib/string.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.endsWith = exports.trim = void 0;\n// From https://youmightnotneed.com/lodash/#trim\nfunction trim(str, c) {\n    if (c === void 0) { c = '\\\\s'; }\n    return str.replace(new RegExp(\"^([\".concat(c, \"]*)(.*?)([\").concat(c, \"]*)$\")), '$2');\n}\nexports.trim = trim;\n// Polyfill from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\nif (!String.prototype.endsWith) {\n    String.prototype.endsWith = function (search, this_len) {\n        if (this_len === undefined || this_len > this.length) {\n            this_len = this.length;\n        }\n        // @ts-ignore: Object is possibly 'undefined'\n        return this.substring(this_len - search.length, this_len) === search;\n    };\n}\n// From https://youmightnotneed.com/lodash/#endsWith\nfunction endsWith(str, c) {\n    return str.endsWith(c);\n}\nexports.endsWith = endsWith;\n\n\n//# sourceURL=webpack://@formio/core/./node_modules/@formio/lodash/lib/string.js?");

/***/ }),

/***/ "./node_modules/browser-cookies/src/browser-cookies.js":
/*!*************************************************************!*\
  !*** ./node_modules/browser-cookies/src/browser-cookies.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("exports.defaults = {};\r\n\r\nexports.set = function(name, value, options) {\r\n  // Retrieve options and defaults\r\n  var opts = options || {};\r\n  var defaults = exports.defaults;\r\n\r\n  // Apply default value for unspecified options\r\n  var expires  = opts.expires  || defaults.expires;\r\n  var domain   = opts.domain   || defaults.domain;\r\n  var path     = opts.path     !== undefined ? opts.path     : (defaults.path !== undefined ? defaults.path : '/');\r\n  var secure   = opts.secure   !== undefined ? opts.secure   : defaults.secure;\r\n  var httponly = opts.httponly !== undefined ? opts.httponly : defaults.httponly;\r\n  var samesite = opts.samesite !== undefined ? opts.samesite : defaults.samesite;\r\n\r\n  // Determine cookie expiration date\r\n  // If succesful the result will be a valid Date, otherwise it will be an invalid Date or false(ish)\r\n  var expDate = expires ? new Date(\r\n      // in case expires is an integer, it should specify the number of days till the cookie expires\r\n      typeof expires === 'number' ? new Date().getTime() + (expires * 864e5) :\r\n      // else expires should be either a Date object or in a format recognized by Date.parse()\r\n      expires\r\n  ) : 0;\r\n\r\n  // Set cookie\r\n  document.cookie = name.replace(/[^+#$&^`|]/g, encodeURIComponent)                // Encode cookie name\r\n  .replace('(', '%28')\r\n  .replace(')', '%29') +\r\n  '=' + value.replace(/[^+#$&/:<-\\[\\]-}]/g, encodeURIComponent) +                  // Encode cookie value (RFC6265)\r\n  (expDate && expDate.getTime() >= 0 ? ';expires=' + expDate.toUTCString() : '') + // Add expiration date\r\n  (domain   ? ';domain=' + domain     : '') +                                      // Add domain\r\n  (path     ? ';path='   + path       : '') +                                      // Add path\r\n  (secure   ? ';secure'               : '') +                                      // Add secure option\r\n  (httponly ? ';httponly'             : '') +                                      // Add httponly option\r\n  (samesite ? ';samesite=' + samesite : '');                                       // Add samesite option\r\n};\r\n\r\nexports.get = function(name) {\r\n  var cookies = document.cookie.split(';');\r\n  \r\n  // Iterate all cookies\r\n  while(cookies.length) {\r\n    var cookie = cookies.pop();\r\n\r\n    // Determine separator index (\"name=value\")\r\n    var separatorIndex = cookie.indexOf('=');\r\n\r\n    // IE<11 emits the equal sign when the cookie value is empty\r\n    separatorIndex = separatorIndex < 0 ? cookie.length : separatorIndex;\r\n\r\n    var cookie_name = decodeURIComponent(cookie.slice(0, separatorIndex).replace(/^\\s+/, ''));\r\n\r\n    // Return cookie value if the name matches\r\n    if (cookie_name === name) {\r\n      return decodeURIComponent(cookie.slice(separatorIndex + 1));\r\n    }\r\n  }\r\n\r\n  // Return `null` as the cookie was not found\r\n  return null;\r\n};\r\n\r\nexports.erase = function(name, options) {\r\n  exports.set(name, '', {\r\n    expires:  -1,\r\n    domain:   options && options.domain,\r\n    path:     options && options.path,\r\n    secure:   0,\r\n    httponly: 0}\r\n  );\r\n};\r\n\r\nexports.all = function() {\r\n  var all = {};\r\n  var cookies = document.cookie.split(';');\r\n\r\n  // Iterate all cookies\r\n  while(cookies.length) {\r\n    var cookie = cookies.pop();\r\n\r\n    // Determine separator index (\"name=value\")\r\n    var separatorIndex = cookie.indexOf('=');\r\n\r\n    // IE<11 emits the equal sign when the cookie value is empty\r\n    separatorIndex = separatorIndex < 0 ? cookie.length : separatorIndex;\r\n\r\n    // add the cookie name and value to the `all` object\r\n    var cookie_name = decodeURIComponent(cookie.slice(0, separatorIndex).replace(/^\\s+/, ''));\r\n    all[cookie_name] = decodeURIComponent(cookie.slice(separatorIndex + 1));\r\n  }\r\n\r\n  return all;\r\n};\r\n\n\n//# sourceURL=webpack://@formio/core/./node_modules/browser-cookies/src/browser-cookies.js?");

/***/ }),

/***/ "./node_modules/eventemitter3/index.js":
/*!*********************************************!*\
  !*** ./node_modules/eventemitter3/index.js ***!
  \*********************************************/
/***/ (function(module) {

"use strict";
eval("\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif (true) {\n  module.exports = EventEmitter;\n}\n\n\n//# sourceURL=webpack://@formio/core/./node_modules/eventemitter3/index.js?");

/***/ }),

/***/ "./node_modules/fetch-ponyfill/build/fetch-browser.js":
/*!************************************************************!*\
  !*** ./node_modules/fetch-ponyfill/build/fetch-browser.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;(function (global) {\n  'use strict';\n\n  function fetchPonyfill(options) {\n    var Promise = options && options.Promise || global.Promise;\n    var XMLHttpRequest = options && options.XMLHttpRequest || global.XMLHttpRequest;\n\n    return (function () {\n      var globalThis = Object.create(global, {\n        fetch: {\n          value: undefined,\n          writable: true\n        }\n      });\n\n      (function (global, factory) {\n         true ? factory(exports) :\n        0;\n      }(this, (function (exports) { 'use strict';\n\n        var global =\n          (typeof globalThis !== 'undefined' && globalThis) ||\n          (typeof self !== 'undefined' && self) ||\n          (typeof global !== 'undefined' && global);\n\n        var support = {\n          searchParams: 'URLSearchParams' in global,\n          iterable: 'Symbol' in global && 'iterator' in Symbol,\n          blob:\n            'FileReader' in global &&\n            'Blob' in global &&\n            (function() {\n              try {\n                new Blob();\n                return true\n              } catch (e) {\n                return false\n              }\n            })(),\n          formData: 'FormData' in global,\n          arrayBuffer: 'ArrayBuffer' in global\n        };\n\n        function isDataView(obj) {\n          return obj && DataView.prototype.isPrototypeOf(obj)\n        }\n\n        if (support.arrayBuffer) {\n          var viewClasses = [\n            '[object Int8Array]',\n            '[object Uint8Array]',\n            '[object Uint8ClampedArray]',\n            '[object Int16Array]',\n            '[object Uint16Array]',\n            '[object Int32Array]',\n            '[object Uint32Array]',\n            '[object Float32Array]',\n            '[object Float64Array]'\n          ];\n\n          var isArrayBufferView =\n            ArrayBuffer.isView ||\n            function(obj) {\n              return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n            };\n        }\n\n        function normalizeName(name) {\n          if (typeof name !== 'string') {\n            name = String(name);\n          }\n          if (/[^a-z0-9\\-#$%&'*+.^_`|~!]/i.test(name) || name === '') {\n            throw new TypeError('Invalid character in header field name')\n          }\n          return name.toLowerCase()\n        }\n\n        function normalizeValue(value) {\n          if (typeof value !== 'string') {\n            value = String(value);\n          }\n          return value\n        }\n\n        // Build a destructive iterator for the value list\n        function iteratorFor(items) {\n          var iterator = {\n            next: function() {\n              var value = items.shift();\n              return {done: value === undefined, value: value}\n            }\n          };\n\n          if (support.iterable) {\n            iterator[Symbol.iterator] = function() {\n              return iterator\n            };\n          }\n\n          return iterator\n        }\n\n        function Headers(headers) {\n          this.map = {};\n\n          if (headers instanceof Headers) {\n            headers.forEach(function(value, name) {\n              this.append(name, value);\n            }, this);\n          } else if (Array.isArray(headers)) {\n            headers.forEach(function(header) {\n              this.append(header[0], header[1]);\n            }, this);\n          } else if (headers) {\n            Object.getOwnPropertyNames(headers).forEach(function(name) {\n              this.append(name, headers[name]);\n            }, this);\n          }\n        }\n\n        Headers.prototype.append = function(name, value) {\n          name = normalizeName(name);\n          value = normalizeValue(value);\n          var oldValue = this.map[name];\n          this.map[name] = oldValue ? oldValue + ', ' + value : value;\n        };\n\n        Headers.prototype['delete'] = function(name) {\n          delete this.map[normalizeName(name)];\n        };\n\n        Headers.prototype.get = function(name) {\n          name = normalizeName(name);\n          return this.has(name) ? this.map[name] : null\n        };\n\n        Headers.prototype.has = function(name) {\n          return this.map.hasOwnProperty(normalizeName(name))\n        };\n\n        Headers.prototype.set = function(name, value) {\n          this.map[normalizeName(name)] = normalizeValue(value);\n        };\n\n        Headers.prototype.forEach = function(callback, thisArg) {\n          for (var name in this.map) {\n            if (this.map.hasOwnProperty(name)) {\n              callback.call(thisArg, this.map[name], name, this);\n            }\n          }\n        };\n\n        Headers.prototype.keys = function() {\n          var items = [];\n          this.forEach(function(value, name) {\n            items.push(name);\n          });\n          return iteratorFor(items)\n        };\n\n        Headers.prototype.values = function() {\n          var items = [];\n          this.forEach(function(value) {\n            items.push(value);\n          });\n          return iteratorFor(items)\n        };\n\n        Headers.prototype.entries = function() {\n          var items = [];\n          this.forEach(function(value, name) {\n            items.push([name, value]);\n          });\n          return iteratorFor(items)\n        };\n\n        if (support.iterable) {\n          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n        }\n\n        function consumed(body) {\n          if (body.bodyUsed) {\n            return Promise.reject(new TypeError('Already read'))\n          }\n          body.bodyUsed = true;\n        }\n\n        function fileReaderReady(reader) {\n          return new Promise(function(resolve, reject) {\n            reader.onload = function() {\n              resolve(reader.result);\n            };\n            reader.onerror = function() {\n              reject(reader.error);\n            };\n          })\n        }\n\n        function readBlobAsArrayBuffer(blob) {\n          var reader = new FileReader();\n          var promise = fileReaderReady(reader);\n          reader.readAsArrayBuffer(blob);\n          return promise\n        }\n\n        function readBlobAsText(blob) {\n          var reader = new FileReader();\n          var promise = fileReaderReady(reader);\n          reader.readAsText(blob);\n          return promise\n        }\n\n        function readArrayBufferAsText(buf) {\n          var view = new Uint8Array(buf);\n          var chars = new Array(view.length);\n\n          for (var i = 0; i < view.length; i++) {\n            chars[i] = String.fromCharCode(view[i]);\n          }\n          return chars.join('')\n        }\n\n        function bufferClone(buf) {\n          if (buf.slice) {\n            return buf.slice(0)\n          } else {\n            var view = new Uint8Array(buf.byteLength);\n            view.set(new Uint8Array(buf));\n            return view.buffer\n          }\n        }\n\n        function Body() {\n          this.bodyUsed = false;\n\n          this._initBody = function(body) {\n            /*\n              fetch-mock wraps the Response object in an ES6 Proxy to\n              provide useful test harness features such as flush. However, on\n              ES5 browsers without fetch or Proxy support pollyfills must be used;\n              the proxy-pollyfill is unable to proxy an attribute unless it exists\n              on the object before the Proxy is created. This change ensures\n              Response.bodyUsed exists on the instance, while maintaining the\n              semantic of setting Request.bodyUsed in the constructor before\n              _initBody is called.\n            */\n            this.bodyUsed = this.bodyUsed;\n            this._bodyInit = body;\n            if (!body) {\n              this._bodyText = '';\n            } else if (typeof body === 'string') {\n              this._bodyText = body;\n            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n              this._bodyBlob = body;\n            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n              this._bodyFormData = body;\n            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n              this._bodyText = body.toString();\n            } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n              this._bodyArrayBuffer = bufferClone(body.buffer);\n              // IE 10-11 can't handle a DataView body.\n              this._bodyInit = new Blob([this._bodyArrayBuffer]);\n            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n              this._bodyArrayBuffer = bufferClone(body);\n            } else {\n              this._bodyText = body = Object.prototype.toString.call(body);\n            }\n\n            if (!this.headers.get('content-type')) {\n              if (typeof body === 'string') {\n                this.headers.set('content-type', 'text/plain;charset=UTF-8');\n              } else if (this._bodyBlob && this._bodyBlob.type) {\n                this.headers.set('content-type', this._bodyBlob.type);\n              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n                this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n              }\n            }\n          };\n\n          if (support.blob) {\n            this.blob = function() {\n              var rejected = consumed(this);\n              if (rejected) {\n                return rejected\n              }\n\n              if (this._bodyBlob) {\n                return Promise.resolve(this._bodyBlob)\n              } else if (this._bodyArrayBuffer) {\n                return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n              } else if (this._bodyFormData) {\n                throw new Error('could not read FormData body as blob')\n              } else {\n                return Promise.resolve(new Blob([this._bodyText]))\n              }\n            };\n\n            this.arrayBuffer = function() {\n              if (this._bodyArrayBuffer) {\n                var isConsumed = consumed(this);\n                if (isConsumed) {\n                  return isConsumed\n                }\n                if (ArrayBuffer.isView(this._bodyArrayBuffer)) {\n                  return Promise.resolve(\n                    this._bodyArrayBuffer.buffer.slice(\n                      this._bodyArrayBuffer.byteOffset,\n                      this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength\n                    )\n                  )\n                } else {\n                  return Promise.resolve(this._bodyArrayBuffer)\n                }\n              } else {\n                return this.blob().then(readBlobAsArrayBuffer)\n              }\n            };\n          }\n\n          this.text = function() {\n            var rejected = consumed(this);\n            if (rejected) {\n              return rejected\n            }\n\n            if (this._bodyBlob) {\n              return readBlobAsText(this._bodyBlob)\n            } else if (this._bodyArrayBuffer) {\n              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n            } else if (this._bodyFormData) {\n              throw new Error('could not read FormData body as text')\n            } else {\n              return Promise.resolve(this._bodyText)\n            }\n          };\n\n          if (support.formData) {\n            this.formData = function() {\n              return this.text().then(decode)\n            };\n          }\n\n          this.json = function() {\n            return this.text().then(JSON.parse)\n          };\n\n          return this\n        }\n\n        // HTTP methods whose capitalization should be normalized\n        var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];\n\n        function normalizeMethod(method) {\n          var upcased = method.toUpperCase();\n          return methods.indexOf(upcased) > -1 ? upcased : method\n        }\n\n        function Request(input, options) {\n          if (!(this instanceof Request)) {\n            throw new TypeError('Please use the \"new\" operator, this DOM object constructor cannot be called as a function.')\n          }\n\n          options = options || {};\n          var body = options.body;\n\n          if (input instanceof Request) {\n            if (input.bodyUsed) {\n              throw new TypeError('Already read')\n            }\n            this.url = input.url;\n            this.credentials = input.credentials;\n            if (!options.headers) {\n              this.headers = new Headers(input.headers);\n            }\n            this.method = input.method;\n            this.mode = input.mode;\n            this.signal = input.signal;\n            if (!body && input._bodyInit != null) {\n              body = input._bodyInit;\n              input.bodyUsed = true;\n            }\n          } else {\n            this.url = String(input);\n          }\n\n          this.credentials = options.credentials || this.credentials || 'same-origin';\n          if (options.headers || !this.headers) {\n            this.headers = new Headers(options.headers);\n          }\n          this.method = normalizeMethod(options.method || this.method || 'GET');\n          this.mode = options.mode || this.mode || null;\n          this.signal = options.signal || this.signal;\n          this.referrer = null;\n\n          if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n            throw new TypeError('Body not allowed for GET or HEAD requests')\n          }\n          this._initBody(body);\n\n          if (this.method === 'GET' || this.method === 'HEAD') {\n            if (options.cache === 'no-store' || options.cache === 'no-cache') {\n              // Search for a '_' parameter in the query string\n              var reParamSearch = /([?&])_=[^&]*/;\n              if (reParamSearch.test(this.url)) {\n                // If it already exists then set the value with the current time\n                this.url = this.url.replace(reParamSearch, '$1_=' + new Date().getTime());\n              } else {\n                // Otherwise add a new '_' parameter to the end with the current time\n                var reQueryString = /\\?/;\n                this.url += (reQueryString.test(this.url) ? '&' : '?') + '_=' + new Date().getTime();\n              }\n            }\n          }\n        }\n\n        Request.prototype.clone = function() {\n          return new Request(this, {body: this._bodyInit})\n        };\n\n        function decode(body) {\n          var form = new FormData();\n          body\n            .trim()\n            .split('&')\n            .forEach(function(bytes) {\n              if (bytes) {\n                var split = bytes.split('=');\n                var name = split.shift().replace(/\\+/g, ' ');\n                var value = split.join('=').replace(/\\+/g, ' ');\n                form.append(decodeURIComponent(name), decodeURIComponent(value));\n              }\n            });\n          return form\n        }\n\n        function parseHeaders(rawHeaders) {\n          var headers = new Headers();\n          // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n          // https://tools.ietf.org/html/rfc7230#section-3.2\n          var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ');\n          // Avoiding split via regex to work around a common IE11 bug with the core-js 3.6.0 regex polyfill\n          // https://github.com/github/fetch/issues/748\n          // https://github.com/zloirock/core-js/issues/751\n          preProcessedHeaders\n            .split('\\r')\n            .map(function(header) {\n              return header.indexOf('\\n') === 0 ? header.substr(1, header.length) : header\n            })\n            .forEach(function(line) {\n              var parts = line.split(':');\n              var key = parts.shift().trim();\n              if (key) {\n                var value = parts.join(':').trim();\n                headers.append(key, value);\n              }\n            });\n          return headers\n        }\n\n        Body.call(Request.prototype);\n\n        function Response(bodyInit, options) {\n          if (!(this instanceof Response)) {\n            throw new TypeError('Please use the \"new\" operator, this DOM object constructor cannot be called as a function.')\n          }\n          if (!options) {\n            options = {};\n          }\n\n          this.type = 'default';\n          this.status = options.status === undefined ? 200 : options.status;\n          this.ok = this.status >= 200 && this.status < 300;\n          this.statusText = 'statusText' in options ? options.statusText : '';\n          this.headers = new Headers(options.headers);\n          this.url = options.url || '';\n          this._initBody(bodyInit);\n        }\n\n        Body.call(Response.prototype);\n\n        Response.prototype.clone = function() {\n          return new Response(this._bodyInit, {\n            status: this.status,\n            statusText: this.statusText,\n            headers: new Headers(this.headers),\n            url: this.url\n          })\n        };\n\n        Response.error = function() {\n          var response = new Response(null, {status: 0, statusText: ''});\n          response.type = 'error';\n          return response\n        };\n\n        var redirectStatuses = [301, 302, 303, 307, 308];\n\n        Response.redirect = function(url, status) {\n          if (redirectStatuses.indexOf(status) === -1) {\n            throw new RangeError('Invalid status code')\n          }\n\n          return new Response(null, {status: status, headers: {location: url}})\n        };\n\n        exports.DOMException = global.DOMException;\n        try {\n          new exports.DOMException();\n        } catch (err) {\n          exports.DOMException = function(message, name) {\n            this.message = message;\n            this.name = name;\n            var error = Error(message);\n            this.stack = error.stack;\n          };\n          exports.DOMException.prototype = Object.create(Error.prototype);\n          exports.DOMException.prototype.constructor = exports.DOMException;\n        }\n\n        function fetch(input, init) {\n          return new Promise(function(resolve, reject) {\n            var request = new Request(input, init);\n\n            if (request.signal && request.signal.aborted) {\n              return reject(new exports.DOMException('Aborted', 'AbortError'))\n            }\n\n            var xhr = new XMLHttpRequest();\n\n            function abortXhr() {\n              xhr.abort();\n            }\n\n            xhr.onload = function() {\n              var options = {\n                status: xhr.status,\n                statusText: xhr.statusText,\n                headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n              };\n              options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');\n              var body = 'response' in xhr ? xhr.response : xhr.responseText;\n              setTimeout(function() {\n                resolve(new Response(body, options));\n              }, 0);\n            };\n\n            xhr.onerror = function() {\n              setTimeout(function() {\n                reject(new TypeError('Network request failed'));\n              }, 0);\n            };\n\n            xhr.ontimeout = function() {\n              setTimeout(function() {\n                reject(new TypeError('Network request failed'));\n              }, 0);\n            };\n\n            xhr.onabort = function() {\n              setTimeout(function() {\n                reject(new exports.DOMException('Aborted', 'AbortError'));\n              }, 0);\n            };\n\n            function fixUrl(url) {\n              try {\n                return url === '' && global.location.href ? global.location.href : url\n              } catch (e) {\n                return url\n              }\n            }\n\n            xhr.open(request.method, fixUrl(request.url), true);\n\n            if (request.credentials === 'include') {\n              xhr.withCredentials = true;\n            } else if (request.credentials === 'omit') {\n              xhr.withCredentials = false;\n            }\n\n            if ('responseType' in xhr) {\n              if (support.blob) {\n                xhr.responseType = 'blob';\n              } else if (\n                support.arrayBuffer &&\n                request.headers.get('Content-Type') &&\n                request.headers.get('Content-Type').indexOf('application/octet-stream') !== -1\n              ) {\n                xhr.responseType = 'arraybuffer';\n              }\n            }\n\n            if (init && typeof init.headers === 'object' && !(init.headers instanceof Headers)) {\n              Object.getOwnPropertyNames(init.headers).forEach(function(name) {\n                xhr.setRequestHeader(name, normalizeValue(init.headers[name]));\n              });\n            } else {\n              request.headers.forEach(function(value, name) {\n                xhr.setRequestHeader(name, value);\n              });\n            }\n\n            if (request.signal) {\n              request.signal.addEventListener('abort', abortXhr);\n\n              xhr.onreadystatechange = function() {\n                // DONE (success or failure)\n                if (xhr.readyState === 4) {\n                  request.signal.removeEventListener('abort', abortXhr);\n                }\n              };\n            }\n\n            xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\n          })\n        }\n\n        fetch.polyfill = true;\n\n        if (!global.fetch) {\n          global.fetch = fetch;\n          global.Headers = Headers;\n          global.Request = Request;\n          global.Response = Response;\n        }\n\n        exports.Headers = Headers;\n        exports.Request = Request;\n        exports.Response = Response;\n        exports.fetch = fetch;\n\n        Object.defineProperty(exports, '__esModule', { value: true });\n\n      })));\n\n\n      return {\n        fetch: globalThis.fetch,\n        Headers: globalThis.Headers,\n        Request: globalThis.Request,\n        Response: globalThis.Response,\n        DOMException: globalThis.DOMException\n      };\n    }());\n  }\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return fetchPonyfill;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n}(typeof globalThis !== 'undefined' ? globalThis : typeof self !== 'undefined' ? self : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : this));\n\n\n\n//# sourceURL=webpack://@formio/core/./node_modules/fetch-ponyfill/build/fetch-browser.js?");

/***/ }),

/***/ "./src/sdk/Formio.ts":
/*!***************************!*\
  !*** ./src/sdk/Formio.ts ***!
  \***************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Formio = exports.FormioPathType = void 0;\nconst fetch_ponyfill_1 = __importDefault(__webpack_require__(/*! fetch-ponyfill */ \"./node_modules/fetch-ponyfill/build/fetch-browser.js\"));\nconst lodash_1 = __webpack_require__(/*! @formio/lodash */ \"./node_modules/@formio/lodash/lib/index.js\");\nconst formUtil_1 = __webpack_require__(/*! @formio/utils/formUtil */ \"./src/utils/formUtil.ts\");\nconst jwtDecode_1 = __webpack_require__(/*! @formio/utils/jwtDecode */ \"./src/utils/jwtDecode.ts\");\nconst eventemitter3_1 = __importDefault(__webpack_require__(/*! eventemitter3 */ \"./node_modules/eventemitter3/index.js\"));\nconst browser_cookies_1 = __importDefault(__webpack_require__(/*! browser-cookies */ \"./node_modules/browser-cookies/src/browser-cookies.js\"));\nconst { fetch, Headers } = (0, fetch_ponyfill_1.default)();\nconst Plugins_1 = __importDefault(__webpack_require__(/*! ./Plugins */ \"./src/sdk/Plugins.ts\"));\n/**\n * The different path types for a project.\n */\nvar FormioPathType;\n(function (FormioPathType) {\n    FormioPathType[\"Subdirectories\"] = \"Subdirectories\";\n    FormioPathType[\"Subdomains\"] = \"Subdomains\";\n})(FormioPathType || (exports.FormioPathType = FormioPathType = {}));\n/**\n * The Formio interface class. This is a minimalistic API library that allows you to work with the Form.io API's within JavaScript.\n *\n * ## Usage\n * Creating an instance of Formio is simple, and takes only a path (URL String). The path can be different, depending on the desired output.\n * The Formio instance can also access higher level operations, depending on how granular of a path you start with.\n *\n * ```ts\n * var formio = new Formio(<endpoint>, [options]);\n * ```\n *\n * Where **endpoint** is any valid API endpoint within Form.io. These URL's can provide a number of different methods depending on the granularity of the endpoint. This allows you to use the same interface but have access to different methods depending on how granular the endpoint url is.\n * **options** is defined within the {link Formio.constructor} documentation.\n *\n * Here is an example of how this library can be used to load a form JSON from the Form.io API's\n *\n * ```ts\n * const formio = new Formio('https://examples.form.io/example');\n * formio.loadForm().then((form) => {\n *   console.log(form);\n * });\n * ```\n */\nclass Formio {\n    /* eslint-disable max-statements */\n    /**\n     * @constructor\n     * @param {string} path - A project, form, and submission API Url.\n     * @param {FormioOptions} options - Available options to configure the Javascript API.\n     */\n    constructor(path, options = {}) {\n        this.path = path;\n        this.options = options;\n        /**\n         * The base API url of the Form.io Platform. Example: https://api.form.io\n         */\n        this.base = '';\n        /**\n         * The Projects Endpoint derived from the provided source.\n         *\n         * @example https://api.form.io/project\n         */\n        this.projectsUrl = '';\n        /**\n         * A specific project endpoint derived from the provided source.\n         *\n         * @example https://examples.form.io\n         */\n        this.projectUrl = '';\n        /**\n         * The Project ID found within the provided source.\n         */\n        this.projectId = '';\n        /**\n         * A specific Role URL provided the source.\n         *\n         * @example https://examples.form.io/role/2342343234234234\n         */\n        this.roleUrl = '';\n        /**\n         * The roles endpoint derived from the provided source.\n         *\n         * @example https://examples.form.io/role\n         */\n        this.rolesUrl = '';\n        /**\n         * The roleID derieved from the provided source.\n         */\n        this.roleId = '';\n        /**\n         * A specific form url derived from the provided source.\n         *\n         * @example https://examples.form.io/example\n         */\n        this.formUrl = '';\n        /**\n         * The forms url derived from the provided source.\n         *\n         * @example https://example.form.io/form\n         */\n        this.formsUrl = '';\n        /**\n         * The Form ID derived from the provided source.\n         */\n        this.formId = '';\n        /**\n         * The submissions URL derived from the provided source.\n         *\n         * @example https://examples.form.io/example/submission\n         */\n        this.submissionsUrl = '';\n        /**\n         * A specific submissions URL derived from a provided source.\n         *\n         * @example https://examples.form.io/example/submission/223423423423\n         */\n        this.submissionUrl = '';\n        /**\n         * The submission ID provided a submission url.\n         */\n        this.submissionId = '';\n        /**\n         * The actions url provided a form url as the source.\n         *\n         * @example https://examples.form.io/example/action\n         */\n        this.actionsUrl = '';\n        /**\n         * The Action ID derived from a provided Action url.\n         */\n        this.actionId = '';\n        /**\n         * A specific action api endoint.\n         */\n        this.actionUrl = '';\n        this.vsUrl = '';\n        this.vId = '';\n        this.vUrl = '';\n        /**\n         * The query string derived from the provided src url.\n         */\n        this.query = '';\n        /**\n         * If this is a non-project url, such is the case for Open Source API.\n         */\n        this.noProject = false;\n        // Ensure we have an instance of Formio.\n        if (!(this instanceof Formio)) {\n            return new Formio(path);\n        }\n        if (options.useSessionToken) {\n            Formio.useSessionToken(options);\n        }\n        if (options.hasOwnProperty('base') && options.base) {\n            this.base = options.base;\n        }\n        else if (Formio.baseUrl) {\n            this.base = Formio.baseUrl;\n        }\n        else if (window && window.location) {\n            this.base = window.location.href.match(/http[s]?:\\/\\/api./)[0];\n        }\n        if (!path) {\n            // Allow user to create new projects if this was instantiated without\n            // a url\n            this.projectUrl = Formio.projectUrl || `${this.base}/project`;\n            this.projectsUrl = `${this.base}/project`;\n            this.projectId = '';\n            this.query = '';\n            return;\n        }\n        if (options.hasOwnProperty('project') && options.project) {\n            this.projectUrl = options.project;\n        }\n        const project = this.projectUrl || Formio.projectUrl;\n        const projectRegEx = /(^|\\/)(project)($|\\/[^/]+)/;\n        const isProjectUrl = (path.search(projectRegEx) !== -1);\n        // The baseURL is the same as the projectUrl, and does not contain \"/project/MONGO_ID\" in\n        // its domain. This is almost certainly against the Open Source server.\n        if (project && this.base === project && !isProjectUrl) {\n            this.noProject = true;\n            this.projectUrl = this.base;\n        }\n        // Normalize to an absolute path.\n        if ((path.indexOf('http') !== 0) && (path.indexOf('//') !== 0)) {\n            path = this.base + path;\n        }\n        const hostparts = this.getUrlParts(path);\n        let hostName = '';\n        let parts = [];\n        if (hostparts) {\n            hostName = hostparts[1] + hostparts[2];\n            path = hostparts.length > 3 ? hostparts[3] : '';\n            const queryparts = path.split('?');\n            if (queryparts.length > 1) {\n                path = queryparts[0];\n                this.query = `?${queryparts[1]}`;\n            }\n        }\n        // Register a specific path.\n        const registerPath = (name, base) => {\n            this[`${name}sUrl`] = `${base}/${name}`;\n            const regex = new RegExp(`/${name}/([^/]+)`);\n            if (path && path.search(regex) !== -1) {\n                parts = path.match(regex);\n                this[`${name}Url`] = parts ? (base + parts[0]) : '';\n                this[`${name}Id`] = (parts.length > 1) ? parts[1] : '';\n                base += parts[0];\n            }\n            return base;\n        };\n        // Register an array of items.\n        const registerItems = (items, base, staticBase) => {\n            for (const i in items) {\n                if (items.hasOwnProperty(i)) {\n                    const item = items[i];\n                    if (Array.isArray(item)) {\n                        registerItems(item, base, true);\n                    }\n                    else {\n                        const newBase = registerPath(item, base);\n                        base = staticBase ? base : newBase;\n                    }\n                }\n            }\n        };\n        if (!this.projectUrl || (this.projectUrl === this.base)) {\n            // If a project uses Subdirectories path type, we need to specify a projectUrl\n            if (!this.projectUrl && !isProjectUrl && Formio.pathType === 'Subdirectories') {\n                const regex = `^${hostName.replace(/\\//g, '\\\\/')}.[^/]+`;\n                const match = project.match(new RegExp(regex));\n                this.projectUrl = match ? match[0] : hostName;\n            }\n            else {\n                this.projectUrl = hostName;\n            }\n        }\n        // Check if we have a specified path type.\n        let isNotSubdomainType = false;\n        if (Formio.pathType) {\n            isNotSubdomainType = Formio.pathType !== 'Subdomains';\n        }\n        if (!this.noProject) {\n            // Determine the projectUrl and projectId\n            if (isProjectUrl) {\n                // Get project id as project/:projectId.\n                registerItems(['project'], hostName);\n                path = path.replace(projectRegEx, '');\n            }\n            else if (hostName === this.base) {\n                // Get project id as first part of path (subdirectory).\n                if (hostparts && hostparts.length > 3 && path.split('/').length > 1) {\n                    const isFile = path.match(/.json/);\n                    const pathParts = path.split('/');\n                    if (isFile) {\n                        this.projectUrl = hostName;\n                    }\n                    else {\n                        pathParts.shift(); // Throw away the first /.\n                        const projectId = pathParts.shift();\n                        if (projectId) {\n                            this.projectId = projectId;\n                            path = `/${pathParts.join('/')}`;\n                            this.projectUrl = `${hostName}/${this.projectId}`;\n                        }\n                    }\n                }\n            }\n            else {\n                // Get project id from subdomain.\n                if (hostparts && hostparts.length > 2 && (hostparts[2].split('.').length > 2 || hostName.includes('localhost')) && !isNotSubdomainType) {\n                    this.projectUrl = hostName;\n                    this.projectId = hostparts[2].split('.')[0];\n                }\n            }\n            this.projectsUrl = this.projectsUrl || `${this.base}/project`;\n        }\n        // Configure Role urls and role ids.\n        registerItems(['role'], this.projectUrl);\n        // Configure Form urls and form ids.\n        if (/(^|\\/)(form)($|\\/)/.test(path)) {\n            registerItems(['form', ['submission', 'action', 'v']], this.projectUrl);\n        }\n        else {\n            const subRegEx = new RegExp('/(submission|action|v)($|/.*)');\n            const subs = path.match(subRegEx);\n            if ((subs && (subs.length > 1))) {\n                this.pathType = subs[1];\n            }\n            path = path.replace(subRegEx, '');\n            path = path.replace(/\\/$/, '');\n            this.formsUrl = `${this.projectUrl}/form`;\n            this.formUrl = path ? this.projectUrl + path : '';\n            this.formId = path.replace(/^\\/+|\\/+$/g, '');\n            const items = ['submission', 'action', 'v'];\n            for (const i in items) {\n                if (items.hasOwnProperty(i)) {\n                    const item = items[i];\n                    this[`${item}sUrl`] = `${this.projectUrl + path}/${item}`;\n                    if ((this.pathType === item) && subs && (subs.length > 2) && subs[2]) {\n                        this[`${item}Id`] = subs[2].replace(/^\\/+|\\/+$/g, '');\n                        this[`${item}Url`] = this.projectUrl + path + subs[0];\n                    }\n                }\n            }\n        }\n        // Set the app url if it is not set.\n        if (!Formio.projectUrlSet) {\n            Formio.projectUrl = this.projectUrl;\n        }\n    }\n    /* eslint-enable max-statements */\n    /**\n     * Deletes a remote resource of any provided type.\n     *\n     * @param {string} type - The type of resource to delete. \"submission\", \"form\", etc.\n     * @param {object} options - The options passed to {@link Formio.request}\n     * @return {Promise<Response>}\n     */\n    delete(type, opts) {\n        const _id = `${type}Id`;\n        const _url = `${type}Url`;\n        if (!this[_id]) {\n            return Promise.reject('Nothing to delete');\n        }\n        Formio.cache = {};\n        return this.makeRequest(type, this[_url], 'delete', null, opts);\n    }\n    /**\n     * Returns the index (array of records) for any provided type.\n     *\n     * @param {string} type - The type of resource to fetch the index of. \"submission\", \"form\", etc.\n     * @param {object} query - A query object to pass to the request.\n     * @param {object} query.params - A map (key-value pairs) of URL query parameters to add to the url.\n     * @param {object} options - Options to pass to {@link Formio.request}\n     * @return {Promise<Response>}\n     */\n    index(type, query, opts) {\n        const _url = `${type}Url`;\n        query = query || '';\n        if (query && (0, lodash_1.isObject)(query)) {\n            query = `?${Formio.serialize(query.params)}`;\n        }\n        return this.makeRequest(type, this[_url] + query, 'get', null, opts);\n    }\n    /**\n     * Save a document record using \"upsert\". If the document does not exist, it will be created, if the _id is provided,\n     * it will be updated.\n     *\n     * @param {string} type - The type of resource to fetch the index of. \"submission\", \"form\", etc.\n     * @param {object} data - The resource data object.\n     * @param {object} options - Options to pass to {@link Formio.request}\n     * @return {Promise<object>}\n     */\n    save(type, data, opts) {\n        const _id = `${type}Id`;\n        const _url = `${type}Url`;\n        const method = (this[_id] || data._id) ? 'put' : 'post';\n        let reqUrl = this[_id] ? this[_url] : this[`${type}sUrl`];\n        if (!this[_id] && data._id && (method === 'put') && !reqUrl.includes(data._id)) {\n            reqUrl += `/${data._id}`;\n        }\n        Formio.cache = {};\n        return this.makeRequest(type, reqUrl + this.query, method, data, opts);\n    }\n    /**\n     * @summary Load (GET) a document record.\n     *\n     * @param {string} type - The type of resource to fetch the index of. \"submission\", \"form\", etc.\n     * @param {object} query - A query object to pass to the request.\n     * @param {object} query.params - A map (key-value pairs) of URL query parameters to add to the url.\n     * @param {object} options - Options to pass to {@link Formio.request}\n     * @return {Promise<object>}\n     */\n    load(type, query, opts) {\n        const _id = `${type}Id`;\n        const _url = `${type}Url`;\n        if (query && (0, lodash_1.isObject)(query)) {\n            query = Formio.serialize(query.params);\n        }\n        if (query) {\n            query = this.query ? (`${this.query}&${query}`) : (`?${query}`);\n        }\n        else {\n            query = this.query;\n        }\n        if (!this[_id]) {\n            return Promise.reject(`Missing ${_id}`);\n        }\n        let url = this[_url] + query;\n        if (type === 'form' && !isNaN(parseInt(this.vId))) {\n            url += url.indexOf('?') === -1 ? '?' : '&';\n            url += `formRevision=${this.vId}`;\n        }\n        return this.makeRequest(type, url, 'get', null, opts);\n    }\n    /**\n     * @summary Call {@link Formio.makeRequest} for this Formio instance.\n     *\n     * @param {string} type - The request resource type. \"submission\", \"form\", etc.\n     * @param {string} url - The URL to request.\n     * @param {string} method - The request method. GET, PUT, POST, DELETE, or PATCH\n     * @param {object} data - The data to pass to the request (for PUT, POST, and PATCH methods)\n     * @param {object} options - An object of options to pass to the request method.\n     * @param {boolean} options.ignoreCache - To ignore internal caching of the request.\n     * @param {object} options.headers - An object of headers to pass along to the request.\n     * @param {boolean} options.noToken - If set to true, this will not include the Form.io x-jwt-token along with the request.\n     * @param {string} options.namespace - The Form.io namespace to prepend to all LocalStorage variables such as formioToken.\n     * @param {boolean} options.getHeaders - Set this if you wish to include the response headers with the return of this method.\n     * @return {Promise<Response>}\n     */\n    makeRequest(type, url, method, data, opts) {\n        return Formio.makeRequest(this, type, url, method, data, opts);\n    }\n    /**\n     * @summary Loads a project.\n     *\n     * ```ts\n     * const formio = new Formio('https://examples.form.io');\n     * formio.loadProject().then((project) => {\n     *   console.log(project);\n     * });\n     * ```\n     *\n     * @param {object} query - Query parameters to pass to {@link Formio#load}.\n     * @param {object} options - Options to pass to {@link Formio.request}\n     * @return {Promise<Object>}\n     */\n    loadProject(query, opts) {\n        return this.load('project', query, opts);\n    }\n    /**\n     * Saves or Updates a project.\n     *\n     * ### Create a new project\n     * ```ts\n     * const formio = new Formio();\n     * formio.saveProject({\n     *   title: 'My Project',\n     *   path: 'myproject',\n     *   name: 'myproject'\n     * });\n     * ```\n     *\n     * ### Update an existing project\n     * ```ts\n     * const formio = new Formio('https://examples.form.io');\n     * formio.loadProject().then((project) => {\n     *   project.title = 'Title changed';\n     *   formio.saveProject(project).then(() => {\n     *     console.log('Done saving project!');\n     *   });\n     * });\n     * ```\n     *\n     * @param {object} data - The project JSON to create or update.\n     * @param {object} options - Options to pass to {@link Formio.request}\n     * @return {Promise<Object>}\n     */\n    saveProject(data, opts) {\n        return this.save('project', data, opts);\n    }\n    /**\n     * Deletes a project\n     *\n     * ```ts\n     * const formio = new Formio('https://examples.form.io');\n     * formio.deleteProject();\n     * ```\n     *\n     * @param {object} options - Options to pass to {@link Formio.request}\n     * @return {Promise<Object>}\n     */\n    deleteProject(opts) {\n        return this.delete('project', opts);\n    }\n    /**\n     * Loads a list of all projects.\n     *\n     * ```ts\n     * Formio.loadProjects().then((projects) => {\n     *   console.log(projects);\n     * });\n     * ```\n     *\n     * @param {object} query - Query parameters similar to {@link Formio#load}.\n     * @param {object} options - Options to pass to {@link Formio.request}\n     * @return {*}\n     */\n    static loadProjects(query, opts) {\n        query = query || '';\n        if ((0, lodash_1.isObject)(query)) {\n            query = `?${Formio.serialize(query.params)}`;\n        }\n        return Formio.makeStaticRequest(`${Formio.baseUrl}/project${query}`, 'GET', null, opts);\n    }\n    /**\n     * Loads a role within a project.\n     *\n     * ```ts\n     * const formio = new Formio('https://examples.form.io/role/234234234234');\n     * formio.loadRole().then((role) => {\n     *   console.log(role);\n     * });\n     * ```\n     *\n     * @param {object} options - Options to pass to {@link Formio.request}\n     * @return {Promise<Object>}\n     */\n    loadRole(opts) {\n        return this.load('role', null, opts);\n    }\n    /**\n     * Create a new or Update an existing role within a project.\n     *\n     * ### Create new Role example\n     * ```ts\n     * const formio = new Formio('https://examples.form.io');\n     * formio.saveRole({\n     *   title: 'Employee',\n     *   description: 'A person who belongs to a company.'\n     * }).then((role) => {\n     *   console.log(role);\n     * });\n     * ```\n     *\n     * ### Update existing role example\n     * ```ts\n     * const formio = new Formio('https://examples.form.io/role/234234234234234');\n     * formio.loadRole().then((role) => {\n     *   role.title = 'Manager';\n     *   formio.saveRole(role).then(() => {\n     *     console.log('DONE');\n     *   });\n     * });\n     * ```\n     *\n     * @param {object} role - The Role JSON to create or update.\n     * @param {object} options - Options to pass to {@link Formio.request}\n     * @return {Promise<Object>}\n     */\n    saveRole(data, opts) {\n        return this.save('role', data, opts);\n    }\n    /**\n     * Deletes a role within a project.\n     *\n     * @param {object} options - Options to pass to {@link Formio.request}\n     * @return {Promise<Response>}\n     */\n    deleteRole(opts) {\n        return this.delete('role', opts);\n    }\n    /**\n     * Load all roles within a project.\n     *\n     * ```ts\n     * const formio = new Formio('https://examples.form.io');\n     * formio.loadRoles().then((roles) => {\n     *   console.log(roles);\n     * });\n     * ```\n     *\n     * @param {object} options - Options to pass to {@link Formio.request}\n     * @return {Promise<Response>}\n     */\n    loadRoles(opts) {\n        return this.index('roles', null, opts);\n    }\n    /**\n     * Loads a form.\n     *\n     * ```ts\n     * const formio = new Formio('https://examples.form.io/example');\n     * formio.loadForm().then((form) => {\n     *   console.log(form);\n     * });\n     * ```\n     *\n     * @param {object} query - Query parameters similar to {@link Formio#load}.\n     * @param {object} options - Options to pass to {@link Formio.request}\n     * @return {Promise<object>}\n     */\n    loadForm(query, opts) {\n        return this.load('form', query, opts)\n            .then((currentForm) => {\n            // Check to see if there isn't a number in vId.\n            if (!currentForm.revisions || isNaN(parseInt(this.vId))) {\n                return currentForm;\n            }\n            // If a submission already exists but form is marked to load current version of form.\n            if (currentForm.revisions === 'current' && this.submissionId) {\n                return currentForm;\n            }\n            // eslint-disable-next-line eqeqeq\n            if (currentForm._vid == this.vId || currentForm.revisionId === this.vId) {\n                return currentForm;\n            }\n            // If they specified a revision form, load the revised form components.\n            if (query && (0, lodash_1.isObject)(query)) {\n                query = Formio.serialize(query.params);\n            }\n            if (query) {\n                query = this.query ? (`${this.query}&${query}`) : (`?${query}`);\n            }\n            else {\n                query = this.query;\n            }\n            return this.makeRequest('form', this.vUrl + query, 'get', null, opts)\n                .then((revisionForm) => {\n                currentForm._vid = revisionForm._vid;\n                currentForm.components = revisionForm.components;\n                currentForm.settings = revisionForm.settings;\n                currentForm.revisionId = revisionForm.revisionId;\n                // Using object.assign so we don't cross polinate multiple form loads.\n                return Object.assign({}, currentForm);\n            })\n                // If we couldn't load the revision, just return the original form.\n                .catch(() => Object.assign({}, currentForm));\n        });\n    }\n    /**\n     * Create or Update a specific form.\n     *\n     * ### Create form example\n     * ```ts\n     * const formio = new Formio('https://examples.form.io');\n     * formio.saveForm({\n     *   title: 'Employee',\n     *   type: 'resource',\n     *   path: 'employee',\n     *   name: 'employee',\n     *   components: [\n     *     {\n     *       type: 'textfield',\n     *       key: 'firstName',\n     *       label: 'First Name'\n     *     },\n     *     {\n     *       type: 'textfield',\n     *       key: 'lastName',\n     *       label: 'Last Name'\n     *     }\n     *   ]\n     * });\n     * ```\n     *\n     * ### Update a form example\n     * ```ts\n     * const formio = new Formio('https://examples.form.io/example');\n     * formio.loadForm().then((form) => {\n     *   form.title = 'Changed Title';\n     *   formio.saveForm(form).then(() => {\n     *     console.log('DONE!!!');\n     *   });\n     * });\n     * ```\n     *\n     * @param {object} data - The Form JSON to create or update.\n     * @param {object} options - Options to pass to {@link Formio.request}\n     * @return {Promise<Object>}\n     */\n    saveForm(data, opts) {\n        return this.save('form', data, opts);\n    }\n    /**\n     * Deletes a form.\n     *\n     * ```ts\n     * const formio = new Formio('https://examples.form.io/example');\n     * formio.deleteForm().then(() => {\n     *   console.log('Deleted!');\n     * });\n     * ```\n     *\n     * @param {object} options - Options to pass to {@link Formio.request}\n     * @return {Promise<Response>}\n     */\n    deleteForm(opts) {\n        return this.delete('form', opts);\n    }\n    /**\n     * Loads all forms within a project.\n     *\n     * ```ts\n     * const formio = new Formio('https://examples.form.io');\n     * formio.loadForms().then((forms) => {\n     *   console.log(forms);\n     * });\n     * ```\n     *\n     * @param {object} query - Query parameters similar to {@link Formio#load}.\n     * @param {object} options - Options to pass to {@link Formio.request}\n     * @return {Promise<Response>}\n     */\n    loadForms(query, opts) {\n        return this.index('forms', query, opts);\n    }\n    /**\n     * Loads a specific submissionn.\n     *\n     * ```ts\n     * const formio = new Formio('https://examples.form.io/example/submission/23423423423423423');\n     * formio.loadSubmission().then((submission) => {\n     *   console.log(submission);\n     * });\n     * ```\n     *\n     * @param {object} query - Query parameters similar to {@link Formio#load}.\n     * @param {object} options - Options to pass to {@link Formio.request}\n     * @return {Promise<object>}\n     */\n    loadSubmission(query, opts) {\n        return this.load('submission', query, opts)\n            .then((submission) => {\n            this.vId = submission._frid || submission._fvid;\n            this.vUrl = `${this.formUrl}/v/${this.vId}`;\n            return submission;\n        });\n    }\n    /**\n     * Creates a new or Updates an existing submission.\n     *\n     * ### Create a new submission\n     * ```ts\n     * const formio = new Formio('https://examples.form.io/example');\n     * formio.saveSubmission({\n     *   data: {\n     *     firstName: 'Joe',\n     *     lastName: 'Smith'\n     *   }\n     * }).then((submission) => {\n     *   // This will now be the complete submission object saved on the server.\n     *   console.log(submission);\n     * });\n     * ```\n     *\n     * ### Update an existing submission\n     * ```ts\n     * const formio = new Formio('https://examples.form.io/example/submission/23423423423423423');\n     * formio.loadSubmission().then((submission) => {\n     *   submission.data.lastName = 'Thompson';\n     *   formio.saveSubmission(submission).then(() => {\n     *     console.log('DONE');\n     *   });\n     * });\n     * ```\n     *\n     * @param {object} data - The submission JSON object.\n     * @param {object} options - Options to pass to {@link Formio.request}\n     * @return {Promise<Object>}\n     */\n    saveSubmission(data, opts) {\n        if (!isNaN(parseInt(this.vId)) && !data._fvid) {\n            data._fvid = this.vId;\n        }\n        return this.save('submission', data, opts);\n    }\n    /**\n     * Deletes a submission.\n     *\n     * @param {object} options - Options to pass to {@link Formio.request}\n     * @return {Promise<Response>}\n     */\n    deleteSubmission(opts) {\n        return this.delete('submission', opts);\n    }\n    /**\n     * Loads all submissions within a form.\n     *\n     * ```ts\n     * const formio = new Formio('https://examples.form.io/example');\n     * formio.loadSubmissions({\n     *   params: {\n     *     limit: 25,\n     *     'data.lastName__regex': 'smith'\n     *   }\n     * }).then((submissions) => {\n     *   // Should print out 25 submissions where the last name contains \"smith\".\n     *   console.log(submissions);\n     * });\n     * ```\n     *\n     * @param {object} query - Query parameters similar to {@link Formio#load}.\n     * @param {object} options - Options to pass to {@link Formio.request}\n     * @return {Promise<Response>}\n     */\n    loadSubmissions(query, opts) {\n        return this.index('submissions', query, opts);\n    }\n    /**\n     * Loads a form action.\n     *\n     * ```ts\n     * const formio = new Formio('https://examples.form.io/example/action/234234234234');\n     * formio.loadAction().then((action) => {\n     *   console.log(action);\n     * });\n     * ```\n     *\n     * @param {object} query - Query parameters similar to {@link Formio#load}.\n     * @param {object} options - Options to pass to {@link Formio.request}\n     * @return {Promise<Object>}\n     */\n    loadAction(query, opts) {\n        return this.load('action', query, opts);\n    }\n    /**\n     * Create a new or update an existing action.\n     *\n     * ### Create a new action for a form.\n     * ```ts\n     * const formio = new Formio('https://examples.form.io/example');\n     * formio.saveAction({\n     *   data: {\n     *     name: 'webhook',\n     *     title: 'Webhook Action',\n     *     method: ['create', 'update', 'delete'],\n     *     handler: ['after'],\n     *     condition: {},\n     *     settings: {\n     *       url: 'https://example.com',\n     *       headers: [{}],\n     *       block: false,\n     *       forwardHeaders: false\n     *     }\n     *   }\n     * }).then((action) => {\n     *   console.log(action);\n     * });\n     * ```\n     *\n     * ### Update an action\n     * ```ts\n     * const formio = new Formio('https://examples.form.io/example/action/234234234234');\n     * formio.loadAction().then((action) => {\n     *   action.title = 'Updated title';\n     *   formio.saveAction(action).then(() => {\n     *     console.log('Done!');\n     *   });\n     * });\n     * ```\n     *\n     * @param {object} data - The action JSON\n     * @param {object} options - Options to pass to {@link Formio.request}\n     * @return {Promise<Object>}\n     */\n    saveAction(data, opts) {\n        return this.save('action', data, opts);\n    }\n    /**\n     * Delete an action\n     *\n     * ```ts\n     * const formio = new Formio('https://examples.form.io/example/action/234234234234');\n     * formio.deleteAction().then(() => {\n     *   console.log('Action was deleted.');\n     * });\n     * ```\n     *\n     * @param {object} options - Options to pass to {@link Formio.request}\n     * @return {Promise<Response>}\n     */\n    deleteAction(opts) {\n        return this.delete('action', opts);\n    }\n    /**\n     * Loads all actions within a form.\n     *\n     * ```ts\n     * const formio = new Formio('https://examples.form.io/example');\n     * formio.loadActions().then((actions) => {\n     *   console.log(actions);\n     * });\n     * ```\n     *\n     * @param {object} query - Query parameters similar to {@link Formio#load}.\n     * @param {object} options - Options to pass to {@link Formio.request}\n     * @return {Promise<Response>}\n     */\n    loadActions(query, opts) {\n        return this.index('actions', query, opts);\n    }\n    /**\n     * Returns a list of available actions\n     *\n     * @return {Promise<Response>}\n     */\n    availableActions() {\n        return this.makeRequest('availableActions', `${this.formUrl}/actions`);\n    }\n    /**\n     * Returns the action information for a specific action, such as \"save\".\n     *\n     * ```ts\n     * const formio = new Formio('https://examples.form.io/example/actions/save');\n     * formio.actionInfo().then((info) => {\n     *   console.log(info);\n     * });\n     * ```\n     *\n     * @param {string} name - The name of the action you would like to get information for. i.e. \"save\", \"webhook\", etc.\n     * @return {Promise<Response>}\n     */\n    actionInfo(name) {\n        return this.makeRequest('actionInfo', `${this.formUrl}/actions/${name}`);\n    }\n    /**\n     * Determine if a string ID is a valid MongoID.\n     *\n     * @param {string} id - The id that should be tested if it is avalid id.\n     * @return {boolean} - true if it is a valid MongoId, false otherwise.\n     */\n    isObjectId(id) {\n        const checkForHexRegExp = new RegExp('^[0-9a-fA-F]{24}$');\n        return checkForHexRegExp.test(id);\n    }\n    /**\n     * Get the project ID of project.\n     *\n     * ```ts\n     * const formio = new Formio('https://examples.form.io');\n     * formio.getProjectId().then((projectId) => {\n     *   console.log(projectId);\n     * };\n     * ```\n     *\n     * @return {Promise<string>}\n     */\n    getProjectId() {\n        if (!this.projectId) {\n            return Promise.resolve('');\n        }\n        if (this.isObjectId(this.projectId)) {\n            return Promise.resolve(this.projectId);\n        }\n        else {\n            return this.loadProject().then((project) => {\n                return project._id;\n            });\n        }\n    }\n    /**\n     * Get the ID of a form.\n     *\n     * ```ts\n     * const formio = new Formio('https://examples.form.io/example');\n     * formio.getFormId().then((formId) => {\n     *   console.log(formId);\n     * });\n     * ```\n     *\n     * @return {Promise<string>}\n     */\n    getFormId() {\n        if (!this.formId) {\n            return Promise.resolve('');\n        }\n        if (this.isObjectId(this.formId)) {\n            return Promise.resolve(this.formId);\n        }\n        else {\n            return this.loadForm().then((form) => {\n                return form._id;\n            });\n        }\n    }\n    /**\n     * Instance method for {@link Formio.currentUser}\n     *\n     * @param {object} options - Options to pass to {@link Formio.request}\n     * @return {Promise<object>}\n     */\n    currentUser(options) {\n        return Formio.currentUser(this, options);\n    }\n    /**\n     * Instance method for {@link Formio.accessInfo}\n     *\n     * @return {Promise<Response>}\n     */\n    accessInfo() {\n        return Formio.accessInfo(this);\n    }\n    /**\n     * Sets OAuth Logout URL.\n     *\n     * @param {string} uri - Logout URL.\n     * @param {string} options.namespace - The localStorage namespace to use when retrieving tokens from storage.\n     * @return {string}\n     */\n    oauthLogoutURI(uri, options) {\n        return Formio.oauthLogoutURI(uri, Object.assign({ formio: this }, this.options, options));\n    }\n    /**\n     * Returns the JWT token for this instance.\n     *\n     * @param {object} options - The following options are provided.\n     * @param {string} options.namespace - The localStorage namespace to use when retrieving tokens from storage.\n     * @return {string} - The JWT token for this user.\n     */\n    getToken(options) {\n        return Formio.getToken(Object.assign({ formio: this }, this.options, options));\n    }\n    /**\n     * Sets the JWT token for this instance.\n     *\n     * @param {string} token - The JWT token to set.\n     * @param {object} options - The following options are provided.\n     * @param {string} options.namespace - The localStorage namespace to use when retrieving tokens from storage.\n     * @return {string} - The JWT token that was set.\n     */\n    setToken(token, options) {\n        return Formio.setToken(token, Object.assign({ formio: this }, this.options, options));\n    }\n    /**\n     * Returns a temporary authentication token for single purpose token generation.\n     *\n     * @param {number|string} expire - The amount of seconds to wait before this temp token expires.\n     * @param {string} allowed - The allowed path string inn the format GET:/path\n     * @param {object} options - The options passed to {@link Formio#getToken}\n     */\n    getTempToken(expire, allowed, options) {\n        const token = Formio.getToken(options);\n        if (!token) {\n            return Promise.reject('You must be authenticated to generate a temporary auth token.');\n        }\n        const authUrl = Formio.authUrl || this.projectUrl;\n        return this.makeRequest('tempToken', `${authUrl}/token`, 'GET', null, {\n            ignoreCache: true,\n            header: new Headers({\n                'x-expire': expire,\n                'x-allow': allowed\n            })\n        });\n    }\n    /**\n     * Get a PDF download url for a submission, which will generate a new PDF of the submission. This method will first\n     * fetch a temporary download token, and then append this to the download url for this form.\n     *\n     * ```ts\n     * const formio = new Formio('https://examples.form.io/example/submission/324234234234234');\n     * formio.getDownloadUrl().then((url) => {\n     *   console.log(url);\n     * });\n     * ```\n     *\n     * @param {object} [form] - The form JSON to fetch a download url for.\n     * @return {Promise<string>} - The download url.\n     */\n    getDownloadUrl(form) {\n        if (!this.submissionId) {\n            return Promise.resolve('');\n        }\n        if (!form) {\n            // Make sure to load the form first.\n            return this.loadForm().then((_form) => {\n                if (!_form) {\n                    return '';\n                }\n                return this.getDownloadUrl(_form);\n            });\n        }\n        let apiUrl = `/project/${form.project}`;\n        apiUrl += `/form/${form._id}`;\n        apiUrl += `/submission/${this.submissionId}`;\n        const postfix = form.submissionRevisions && form.settings.changeLog ? '/download/changelog' : '/download';\n        apiUrl += postfix;\n        let download = this.base + apiUrl;\n        return new Promise((resolve, reject) => {\n            this.getTempToken(3600, `GET:${apiUrl}`).then((tempToken) => {\n                download += `?token=${tempToken.key}`;\n                resolve(download);\n            }, () => {\n                resolve(download);\n            }).catch(reject);\n        });\n    }\n    /**\n     * Returns the user permissions to a form and submission.\n     *\n     * @param user - The user or current user if undefined. For anonymous, use \"null\"\n     * @param form - The form or current form if undefined. For no form check, use \"null\"\n     * @param submission - The submisison or \"index\" if undefined.\n     *\n     * @return {{create: boolean, read: boolean, edit: boolean, delete: boolean}}\n     */\n    userPermissions(user, form, submission) {\n        return Promise.all([\n            (form !== undefined) ? Promise.resolve(form) : this.loadForm(),\n            (user !== undefined) ? Promise.resolve(user) : this.currentUser(),\n            (submission !== undefined || !this.submissionId) ? Promise.resolve(submission) : this.loadSubmission(),\n            this.accessInfo()\n        ]).then((results) => {\n            const form = results.shift();\n            const user = results.shift() || { _id: false, roles: [] };\n            const submission = results.shift();\n            const access = results.shift();\n            const permMap = {\n                create: 'create',\n                read: 'read',\n                update: 'edit',\n                delete: 'delete'\n            };\n            const perms = {\n                user: user,\n                form: form,\n                access: access,\n                create: false,\n                read: false,\n                edit: false,\n                delete: false\n            };\n            for (const roleName in access.roles) {\n                if (access.roles.hasOwnProperty(roleName)) {\n                    const role = access.roles[roleName];\n                    if (role.default && (user._id === false)) {\n                        // User is anonymous. Add the anonymous role.\n                        user.roles.push(role._id);\n                    }\n                    else if (role.admin && user.roles.indexOf(role._id) !== -1) {\n                        perms.create = true;\n                        perms.read = true;\n                        perms.delete = true;\n                        perms.edit = true;\n                        return perms;\n                    }\n                }\n            }\n            if (form && form.submissionAccess) {\n                for (let i = 0; i < form.submissionAccess.length; i++) {\n                    const permission = form.submissionAccess[i];\n                    const [perm, scope] = permission.type.split('_');\n                    if (['create', 'read', 'update', 'delete'].includes(perm)) {\n                        if ((0, lodash_1.intersection)(permission.roles, user.roles).length) {\n                            perms[permMap[perm]] = (scope === 'all') || (!submission || (user._id === submission.owner));\n                        }\n                    }\n                }\n            }\n            // check for Group Permissions\n            if (submission) {\n                // we would anyway need to loop through components for create permission, so we'll do that for all of them\n                (0, formUtil_1.eachComponent)(form.components, (component, path) => {\n                    if (component && component.defaultPermission) {\n                        const value = (0, lodash_1.get)(submission.data, path);\n                        // make it work for single-select Group and multi-select Group\n                        const groups = Array.isArray(value) ? value : [value];\n                        groups.forEach(group => {\n                            if (group && group._id && // group id is present\n                                user.roles.indexOf(group._id) > -1 // user has group id in his roles\n                            ) {\n                                if (component.defaultPermission === 'read') {\n                                    perms[permMap.read] = true;\n                                }\n                                if (component.defaultPermission === 'create') {\n                                    perms[permMap.create] = true;\n                                    perms[permMap.read] = true;\n                                }\n                                if (component.defaultPermission === 'write') {\n                                    perms[permMap.create] = true;\n                                    perms[permMap.read] = true;\n                                    perms[permMap.update] = true;\n                                }\n                                if (component.defaultPermission === 'admin') {\n                                    perms[permMap.create] = true;\n                                    perms[permMap.read] = true;\n                                    perms[permMap.update] = true;\n                                    perms[permMap.delete] = true;\n                                }\n                            }\n                        });\n                    }\n                });\n            }\n            return perms;\n        });\n    }\n    /**\n     * `Determine if the current user can submit a form.\n     * @return {*}\n     */\n    canSubmit() {\n        return this.userPermissions().then((perms) => {\n            // If there is user and they cannot create, then check anonymous user permissions.\n            if (!perms.create && Formio.getUser()) {\n                return this.userPermissions(null).then((anonPerms) => {\n                    if (anonPerms.create) {\n                        Formio.setUser(null);\n                        return true;\n                    }\n                    return false;\n                });\n            }\n            return perms.create;\n        });\n    }\n    getUrlParts(url) {\n        return Formio.getUrlParts(url, this);\n    }\n    static getUrlParts(url, formio) {\n        const base = (formio && formio.base) ? formio.base : Formio.baseUrl;\n        let regex = '^(http[s]?:\\\\/\\\\/)';\n        if (base && url.indexOf(base) === 0) {\n            regex += `(${base.replace(/^http[s]?:\\/\\//, '')})`;\n        }\n        else {\n            regex += '([^/]+)';\n        }\n        regex += '($|\\\\/.*)';\n        return url.match(new RegExp(regex));\n    }\n    static serialize(obj, _interpolate) {\n        const str = [];\n        const interpolate = (item) => {\n            return _interpolate ? _interpolate(item) : item;\n        };\n        for (const p in obj) {\n            if (obj.hasOwnProperty(p)) {\n                str.push(`${encodeURIComponent(p)}=${encodeURIComponent(interpolate(obj[p]))}`);\n            }\n        }\n        return str.join('&');\n    }\n    static getRequestArgs(formio, type, url, method, data, opts) {\n        method = (method || 'GET').toUpperCase();\n        if (!opts || !(0, lodash_1.isObject)(opts)) {\n            opts = {};\n        }\n        const requestArgs = {\n            url,\n            method,\n            data: data || null,\n            opts\n        };\n        if (type) {\n            requestArgs.type = type;\n        }\n        if (formio) {\n            requestArgs.formio = formio;\n        }\n        return requestArgs;\n    }\n    static makeStaticRequest(url, method, data, opts) {\n        const requestArgs = Formio.getRequestArgs(null, '', url, method, data, opts);\n        const request = Plugins_1.default.pluginWait('preRequest', requestArgs)\n            .then(() => Plugins_1.default.pluginGet('staticRequest', requestArgs)\n            .then((result) => {\n            if ((0, lodash_1.isNil)(result)) {\n                return Formio.request(requestArgs.url, requestArgs.method, requestArgs.data, requestArgs.opts.header, requestArgs.opts);\n            }\n            return result;\n        }));\n        return Plugins_1.default.pluginAlter('wrapStaticRequestPromise', request, requestArgs);\n    }\n    /**\n     * Make an API request and wrap that request with the Form.io Request plugin system.  This is very similar to the\n     * {Formio.request} method with a difference being that it will pass the request through the Form.io request plugin.\n     *\n     * @param {Formio} formio - An instance of the Formio class.\n     * @param {string} type - The request resource type. \"submission\", \"form\", etc.\n     * @param {string} url - The URL to request.\n     * @param {string} method - The request method. GET, PUT, POST, DELETE, or PATCH\n     * @param {object} data - The data to pass to the request (for PUT, POST, and PATCH methods)\n     * @param {object} options - An object of options to pass to the request method.\n     * @param {boolean} options.ignoreCache - To ignore internal caching of the request.\n     * @param {object} options.headers - An object of headers to pass along to the request.\n     * @param {boolean} options.noToken - If set to true, this will not include the Form.io x-jwt-token along with the request.\n     * @param {string} options.namespace - The Form.io namespace to prepend to all LocalStorage variables such as formioToken.\n     * @param {boolean} options.getHeaders - Set this if you wish to include the response headers with the return of this method.\n     * @return {Promise<Response>}\n     */\n    static makeRequest(formio, type, url, method, data, opts) {\n        if (!formio) {\n            return Formio.makeStaticRequest(url, method, data, opts);\n        }\n        const requestArgs = Formio.getRequestArgs(formio, type, url, method, data, opts);\n        requestArgs.opts = requestArgs.opts || {};\n        requestArgs.opts.formio = formio;\n        //for Formio requests default Accept and Content-type headers\n        if (!requestArgs.opts.headers) {\n            requestArgs.opts.headers = {};\n        }\n        requestArgs.opts.headers = (0, lodash_1.defaults)(requestArgs.opts.headers, {\n            'Accept': 'application/json',\n            'Content-type': 'application/json'\n        });\n        const request = Plugins_1.default.pluginWait('preRequest', requestArgs)\n            .then(() => Plugins_1.default.pluginGet('request', requestArgs)\n            .then((result) => {\n            if ((0, lodash_1.isNil)(result)) {\n                return Formio.request(requestArgs.url, requestArgs.method, requestArgs.data, requestArgs.opts.header, requestArgs.opts);\n            }\n            return result;\n        }));\n        return Plugins_1.default.pluginAlter('wrapRequestPromise', request, requestArgs);\n    }\n    /**\n     * Execute an API request to any external system. This is a wrapper around the Web fetch method.\n     *\n     * ```ts\n     * Formio.request('https://examples.form.io').then((form) => {\n     *   console.log(form);\n     * });\n     * ```\n     *\n     * @param {string} url - The URL to request.\n     * @param {string} method - The request method. GET, PUT, POST, DELETE, or PATCH\n     * @param {object} data - The data to pass to the request (for PUT, POST, and PATCH methods)\n     * @param {Headers} header - An object of headers to pass to the request.\n     * @param {object} options - An object of options to pass to the request method.\n     * @param {boolean} options.ignoreCache - To ignore internal caching of the request.\n     * @param {object} options.headers - An object of headers to pass along to the request.\n     * @param {boolean} options.noToken - If set to true, this will not include the Form.io x-jwt-token along with the request.\n     * @param {string} options.namespace - The Form.io namespace to prepend to all LocalStorage variables such as formioToken.\n     * @param {boolean} options.getHeaders - Set this if you wish to include the response headers with the return of this method.\n     * @return {Promise<Response>|*}\n     */\n    static request(url, method, data, header, opts) {\n        if (!url) {\n            return Promise.reject('No url provided');\n        }\n        method = (method || 'GET').toUpperCase();\n        // For reverse compatibility, if they provided the ignoreCache parameter,\n        // then change it back to the options format where that is a parameter.\n        if ((0, lodash_1.isBoolean)(opts)) {\n            opts = { ignoreCache: opts };\n        }\n        if (!opts || !(0, lodash_1.isObject)(opts)) {\n            opts = {};\n        }\n        // Generate a cachekey.\n        const cacheKey = btoa(encodeURI(url));\n        // Get the cached promise to save multiple loads.\n        if (!opts.ignoreCache && method === 'GET' && Formio.cache.hasOwnProperty(cacheKey)) {\n            return Promise.resolve(Formio.cloneResponse(Formio.cache[cacheKey]));\n        }\n        if (url[0] === '/') {\n            url = Formio.baseUrl + url;\n        }\n        // Set up and fetch request\n        const headers = header || new Headers(opts.headers || {\n            'Accept': 'application/json',\n            'Content-type': 'application/json'\n        });\n        const token = Formio.getToken(opts);\n        if (token && !opts.noToken) {\n            headers.append('x-jwt-token', token);\n        }\n        // The fetch-ponyfill can't handle a proper Headers class anymore. Change it back to an object.\n        const headerObj = {};\n        headers.forEach(function (value, name) {\n            headerObj[name] = value;\n        });\n        let options = {\n            method: method,\n            headers: headerObj,\n            mode: 'cors'\n        };\n        if (data) {\n            options.body = JSON.stringify(data);\n        }\n        // Allow plugins to alter the options.\n        options = Plugins_1.default.pluginAlter('requestOptions', options, url);\n        if (options.namespace || Formio.namespace) {\n            opts.namespace = options.namespace || Formio.namespace;\n        }\n        const requestToken = options.headers['x-jwt-token'];\n        const result = Plugins_1.default.pluginAlter('wrapFetchRequestPromise', Formio.fetch(url, options), { url, method, data, opts }).then((response) => {\n            // Allow plugins to respond.\n            response = Plugins_1.default.pluginAlter('requestResponse', response, Formio, data);\n            if (!response.ok) {\n                if (response.status === 440) {\n                    Formio.setToken(null, opts);\n                    Formio.events.emit('formio.sessionExpired', response.body);\n                }\n                else if (response.status === 401) {\n                    Formio.events.emit('formio.unauthorized', response.body);\n                }\n                else if (response.status === 416) {\n                    Formio.events.emit('formio.rangeIsNotSatisfiable', response.body);\n                }\n                else if (response.status === 504) {\n                    return Promise.reject(new Error('Network request failed'));\n                }\n                // Parse and return the error as a rejected promise to reject this promise\n                return (response.headers.get('content-type').includes('application/json')\n                    ? response.json()\n                    : response.text())\n                    .then((error) => {\n                    return Promise.reject(error);\n                });\n            }\n            // Handle fetch results\n            const token = response.headers.get('x-jwt-token');\n            // In some strange cases, the fetch library will return an x-jwt-token without sending\n            // one to the server. This has even been debugged on the server to verify that no token\n            // was introduced with the request, but the response contains a token. This is an Invalid\n            // case where we do not send an x-jwt-token and get one in return for any GET request.\n            let tokenIntroduced = false;\n            if ((method === 'GET') &&\n                !requestToken &&\n                token &&\n                !opts.external &&\n                !url.includes('token=') &&\n                !url.includes('x-jwt-token=')) {\n                console.warn('Token was introduced in request.');\n                tokenIntroduced = true;\n            }\n            if (response.status >= 200 &&\n                response.status < 300 &&\n                token &&\n                token !== '' &&\n                !tokenIntroduced) {\n                Formio.setToken(token, opts);\n            }\n            // 204 is no content. Don't try to .json() it.\n            if (response.status === 204) {\n                return {};\n            }\n            const getResult = response.headers.get('content-type').includes('application/json')\n                ? response.json()\n                : response.text();\n            return getResult.then((result) => {\n                // Add some content-range metadata to the result here\n                let range = response.headers.get('content-range');\n                if (range && (0, lodash_1.isObject)(result)) {\n                    range = range.split('/');\n                    if (range[0] !== '*') {\n                        const skipLimit = range[0].split('-');\n                        result.skip = Number(skipLimit[0]);\n                        result.limit = skipLimit[1] - skipLimit[0] + 1;\n                    }\n                    result.serverCount = range[1] === '*' ? range[1] : Number(range[1]);\n                }\n                if (!opts.getHeaders) {\n                    return result;\n                }\n                const headers = {};\n                response.headers.forEach((item, key) => {\n                    headers[key] = item;\n                });\n                // Return the result with the headers.\n                return {\n                    result,\n                    headers,\n                };\n            });\n        })\n            .then((result) => {\n            if (opts.getHeaders) {\n                return result;\n            }\n            // Cache the response.\n            if (method === 'GET') {\n                Formio.cache[cacheKey] = result;\n            }\n            return Formio.cloneResponse(result);\n        })\n            .catch((err) => {\n            if (err === 'Bad Token' && opts.noToken !== false) {\n                Formio.setToken(null, opts);\n                Formio.events.emit('formio.badToken', err);\n            }\n            if (err.message) {\n                err = new Error(`Could not connect to API server (${err.message}): ${url}`);\n                err.networkError = true;\n            }\n            if (method === 'GET') {\n                delete Formio.cache[cacheKey];\n            }\n            return Promise.reject(err);\n        });\n        return result;\n    }\n    // Needed to maintain reverse compatability...\n    static get token() {\n        return Formio.tokens.formioToken || '';\n    }\n    // Needed to maintain reverse compatability...\n    static set token(token) {\n        Formio.tokens.formioToken = token || '';\n    }\n    static useSessionToken(options) {\n        let namespace = options;\n        if (typeof options === 'object') {\n            options = options.namespace;\n        }\n        const tokenName = `${namespace || Formio.namespace || 'formio'}Token`;\n        const token = localStorage.getItem(tokenName);\n        if (token) {\n            localStorage.removeItem(tokenName);\n            sessionStorage.setItem(tokenName, token);\n        }\n        const userName = `${namespace || Formio.namespace || 'formio'}User`;\n        const user = localStorage.getItem(userName);\n        if (user) {\n            localStorage.removeItem(userName);\n            sessionStorage.setItem(userName, user);\n        }\n        localStorage.setItem('useSessionToken', 'true');\n    }\n    /**\n     * Sets the JWT in storage to be used within an application.\n     *\n     * @param {string} token - The JWT token to set.\n     * @param {object} options - Options as follows\n     * @param {string} options.namespace - The namespace to save the token within. i.e. \"formio\"\n     * @param {Formio} options.formio - The Formio instance.\n     * @return {Promise<object>|void}\n     */\n    static setToken(token = '', opts = {}) {\n        token = token || '';\n        opts = (typeof opts === 'string') ? { namespace: opts } : opts || {};\n        const tokenName = `${opts.namespace || Formio.namespace || 'formio'}Token`;\n        if (!Formio.tokens) {\n            Formio.tokens = {};\n        }\n        const storage = localStorage.getItem('useSessionToken') ? sessionStorage : localStorage;\n        if (!token) {\n            if (!opts.fromUser) {\n                opts.fromToken = true;\n                Formio.setUser(null, opts);\n            }\n            // iOS in private browse mode will throw an error but we can't detect ahead of time that we are in private mode.\n            try {\n                storage.removeItem(tokenName);\n            }\n            catch (err) {\n                browser_cookies_1.default.erase(tokenName, { path: '/' });\n            }\n            Formio.tokens[tokenName] = token;\n            return Promise.resolve(null);\n        }\n        if (Formio.tokens[tokenName] !== token) {\n            Formio.tokens[tokenName] = token;\n            // iOS in private browse mode will throw an error but we can't detect ahead of time that we are in private mode.\n            try {\n                storage.setItem(tokenName, token);\n            }\n            catch (err) {\n                browser_cookies_1.default.set(tokenName, token, { path: '/' });\n            }\n        }\n        // Return or updates the current user\n        return Formio.currentUser(opts.formio, opts);\n    }\n    /**\n     * Returns the token set within the application for the user.\n     *\n     * @param {object} options - The options as follows.\n     * @param {string} options.namespace - The namespace of the token you wish to fetch.\n     * @param {boolean} options.decode - If you would like the token returned as decoded JSON.\n     * @return {*}\n     */\n    static getToken(options) {\n        options = (typeof options === 'string') ? { namespace: options } : options || {};\n        const tokenName = `${options.namespace || Formio.namespace || 'formio'}Token`;\n        const decodedTokenName = options.decode ? `${tokenName}Decoded` : tokenName;\n        if (!Formio.tokens) {\n            Formio.tokens = {};\n        }\n        if (Formio.tokens[decodedTokenName]) {\n            return Formio.tokens[decodedTokenName];\n        }\n        try {\n            const token = localStorage.getItem('useSessionToken')\n                ? sessionStorage.getItem(tokenName)\n                : localStorage.getItem(tokenName);\n            Formio.tokens[tokenName] = token || '';\n            if (options.decode) {\n                Formio.tokens[decodedTokenName] = Formio.tokens[tokenName] ? (0, jwtDecode_1.jwtDecode)(Formio.tokens[tokenName]) : {};\n                return Formio.tokens[decodedTokenName];\n            }\n            return Formio.tokens[tokenName];\n        }\n        catch (e) {\n            Formio.tokens[tokenName] = browser_cookies_1.default.get(tokenName);\n            return '';\n        }\n    }\n    /**\n     * Sets the current user within the application cache.\n     *\n     * @param {object} user - JSON object of the user you wish to set.\n     * @param {object} options - Options as follows\n     * @param {string} options.namespace - The namespace of the tokens\n     */\n    static setUser(user, opts = {}) {\n        const userName = `${opts.namespace || Formio.namespace || 'formio'}User`;\n        const storage = localStorage.getItem('useSessionToken') ? sessionStorage : localStorage;\n        if (!user) {\n            if (!opts.fromToken) {\n                opts.fromUser = true;\n                Formio.setToken(null, opts);\n            }\n            // Emit an event on the cleared user.\n            Formio.events.emit('formio.user', null);\n            // iOS in private browse mode will throw an error but we can't detect ahead of time that we are in private mode.\n            try {\n                return storage.removeItem(userName);\n            }\n            catch (err) {\n                return browser_cookies_1.default.erase(userName, { path: '/' });\n            }\n        }\n        // iOS in private browse mode will throw an error but we can't detect ahead of time that we are in private mode.\n        try {\n            storage.setItem(userName, JSON.stringify(user));\n        }\n        catch (err) {\n            browser_cookies_1.default.set(userName, JSON.stringify(user), { path: '/' });\n        }\n        // Emit an event on the authenticated user.\n        Formio.events.emit('formio.user', user);\n    }\n    /**\n     * Returns the user JSON.\n     *\n     * @param {object} options - Options as follows\n     * @param {string} namespace - The namespace of the tokens stored within this application.\n     * @return {object} - The user object.\n     */\n    static getUser(options) {\n        options = options || {};\n        const userName = `${options.namespace || Formio.namespace || 'formio'}User`;\n        try {\n            return JSON.parse((localStorage.getItem('useSessionToken')\n                ? sessionStorage\n                : localStorage).getItem(userName) || '');\n        }\n        catch (e) {\n            return JSON.parse(browser_cookies_1.default.get(userName));\n        }\n    }\n    /**\n     * Sets the BaseURL for the application.\n     *\n     * @description Every application developed using the JavaScript SDK must set both the {@link Formio.setBaseUrl} and\n     * {@link Formio.setProjectUrl} methods. These two functions ensure that every URL passed into the constructor of this\n     * class can determine the \"project\" context for which the application is running.\n     *\n     * Any Open Source server applications will set both the {@link Formio.setBaseUrl} and {@link Formio.setProjectUrl}\n     * values will be the same value.\n     *\n     * ```ts\n     * Formio.setBaseUrl('https://yourwebsite.com/forms');\n     * Formio.setProjectUrl('https://yourwebsite.com/forms/project');\n     *\n     * // Now the Formio constructor will know what is the \"project\" and what is the form alias name. Without setBaseUrl\n     * // and setProjectUrl, this would throw an error.\n     *\n     * const formio = new Formio('https://yourwebsite.com/forms/project/user');\n     * formio.loadForm().then((form) => {\n     *   console.log(form);\n     * });\n     * ```\n     *\n     * @param {string} url - The URL of the Base API url.\n     */\n    static setBaseUrl(url) {\n        Formio.baseUrl = url;\n        if (!Formio.projectUrlSet) {\n            Formio.projectUrl = url;\n        }\n    }\n    /**\n     * Returns the current base url described at {@link Formio.setBaseUrl}\n     *\n     * @return {string} - The base url of the application.\n     */\n    static getBaseUrl() {\n        return Formio.baseUrl;\n    }\n    static setApiUrl(url) {\n        return Formio.setBaseUrl(url);\n    }\n    static getApiUrl() {\n        return Formio.getBaseUrl();\n    }\n    static setAppUrl(url) {\n        console.warn('Formio.setAppUrl() is deprecated. Use Formio.setProjectUrl instead.');\n        Formio.projectUrl = url;\n        Formio.projectUrlSet = true;\n    }\n    /**\n     * Sets the Project Url for the application. This is an important method that needs to be set for all applications. It\n     * is documented @ {@link Formio.setBaseUrl}.\n     *\n     * @param {string} url - The project api url.\n     */\n    static setProjectUrl(url) {\n        Formio.projectUrl = url;\n        Formio.projectUrlSet = true;\n    }\n    /**\n     * The Auth URL can be set to customize the authentication requests made from an application. By default, this is\n     * just the same value as {@link Formio.projectUrl}\n     *\n     * @param {string} url - The authentication url\n     */\n    static setAuthUrl(url) {\n        Formio.authUrl = url;\n    }\n    static getAppUrl() {\n        console.warn('Formio.getAppUrl() is deprecated. Use Formio.getProjectUrl instead.');\n        return Formio.projectUrl;\n    }\n    /**\n     * Returns the Project url described at {@link Formio.setProjectUrl}\n     *\n     * @return {string|string} - The Project Url.\n     */\n    static getProjectUrl() {\n        return Formio.projectUrl;\n    }\n    /**\n     * Clears the runtime internal API cache.\n     *\n     * @description By default, the Formio class will cache all API requests in memory so that any subsequent requests\n     * using GET method will return the cached results as long as the API URl is the same as what was cached previously.\n     * This cache can be cleared using this method as follows.\n     *\n     * ```ts\n     * Formio.clearCache();\n     * ```\n     *\n     * Or, if you just wish to clear a single request, then the {@link Formio.request#options.ignoreCache} option can be\n     * provided when making an API request as follows.\n     *\n     * ```ts\n     * Formio.loadForm({}, {\n     *   ignoreCache: true\n     * }).then((form) => {\n     *   console.log(form);\n     * });\n     * ```\n     *\n     * Both of the following will ensure that a new request is made to the API server and that the results will not be\n     * from the cached result.\n     */\n    static clearCache() {\n        Formio.cache = {};\n    }\n    /**\n     * Return the access information about a Project, such as the Role ID's for that project, and if the server is\n     * configured to do so, the Form and Resource access configurations that the authenticated user has access to.\n     *\n     * @description This is useful for an application to determine the UI for a specific user to identify which forms they have\n     * access to submit or read.\n     *\n     * @param {Formio} formio - The Formio instance.\n     * @return {Promise<Response>}\n     */\n    static accessInfo(formio) {\n        const projectUrl = formio ? formio.projectUrl : Formio.projectUrl;\n        return Formio.makeRequest(formio, 'accessInfo', `${projectUrl}/access`);\n    }\n    /**\n     * Returns an array of roles for the project, which includes the ID's and names of those roles.\n     *\n     * @param {Formio} formio - The Formio instance.\n     * @return {Promise<Response>}\n     */\n    static projectRoles(formio) {\n        const projectUrl = formio ? formio.projectUrl : Formio.projectUrl;\n        return Formio.makeRequest(formio, 'projectRoles', `${projectUrl}/role`);\n    }\n    /**\n     * Return the currentUser object. This will fetch the user from the server and respond with the Submission JSON\n     * of that user object.\n     *\n     * @param {Formio} formio - The Formio instance\n     * @param {object} options - The options passed to {@link Formio.getUser}\n     * @return {Promise<R>|*}\n     */\n    static currentUser(formio, options = {}) {\n        let authUrl = Formio.authUrl;\n        if (!authUrl) {\n            authUrl = formio ? formio.projectUrl : (Formio.projectUrl || Formio.baseUrl);\n        }\n        authUrl += '/current';\n        if (!options.ignoreCache || options.fromCurrent) {\n            const user = Formio.getUser(options);\n            if (user) {\n                return Plugins_1.default.pluginAlter('wrapStaticRequestPromise', Promise.resolve(user), {\n                    url: authUrl,\n                    method: 'GET',\n                    options\n                });\n            }\n        }\n        const token = Formio.getToken(options);\n        if ((!options || !options.external) && !token) {\n            return Plugins_1.default.pluginAlter('wrapStaticRequestPromise', Promise.resolve(null), {\n                url: authUrl,\n                method: 'GET',\n                options\n            });\n        }\n        options.fromCurrent = true;\n        return Formio.makeRequest(formio, 'currentUser', authUrl, 'GET', null, options)\n            .then((response) => {\n            Formio.setUser(response, options);\n            return response;\n        });\n    }\n    /**\n     * Performs a logout of the Form.io application. This will reset all cache, as well as make a request to the logout\n     * endpoint of the Form.io api platform.\n     *\n     * @param {Formio} formio - A Formio instance.\n     * @param {object} options - Options passed to both {@link Formio.setToken} as well as {@link Formio.setUser}\n     * @return {Promise<Response>}\n     */\n    static logout(formio, options = {}) {\n        options.formio = formio;\n        const projectUrl = Formio.authUrl ? Formio.authUrl : (formio ? formio.projectUrl : Formio.baseUrl);\n        const logout = () => {\n            Formio.setToken(null, options);\n            Formio.setUser(null, options);\n            Formio.clearCache();\n            localStorage.removeItem('useSessionToken');\n        };\n        return Formio.makeRequest(formio, 'logout', `${projectUrl}/logout`)\n            .then(function (result) {\n            logout();\n            if (result.shouldRedirect && result.url) {\n                window.location.href = result.url;\n            }\n            return result;\n        })\n            .catch(function (err) {\n            logout();\n            throw err;\n        });\n    }\n    /**\n     * Returns the query passed to a page in JSON object format.\n     *\n     * @description For example, lets say you visit your application using\n     * the url as follows.\n     *\n     * ```\n     *   https://yourapplication.com/?token=23423423423&username=Joe\n     * ```\n     *\n     * The following code will provide your application with the following.\n     *\n     * ```ts\n     * const query Formio.pageQuery();\n     * console.log(query.token); // Will print 23423423423\n     * console.log(query.username); // Will print Joe\n     * ```\n     *\n     * @return {{}} - A JSON object representation of the query that was passed to the URL of an application.\n     */\n    static pageQuery() {\n        const pageQuery = {};\n        pageQuery.paths = [];\n        const hashes = location.hash.substr(1).replace(/\\?/g, '&').split('&');\n        let parts = [];\n        location.search.substr(1).split('&').forEach(function (item) {\n            parts = item.split('=');\n            if (parts.length > 1) {\n                pageQuery[parts[0]] = parts[1] && decodeURIComponent(parts[1]);\n            }\n        });\n        hashes.forEach(function (item) {\n            parts = item.split('=');\n            if (parts.length > 1) {\n                pageQuery[parts[0]] = parts[1] && decodeURIComponent(parts[1]);\n            }\n            else if (item.indexOf('/') === 0) {\n                pageQuery.paths = item.substr(1).split('/');\n            }\n        });\n        return pageQuery;\n    }\n    /**\n     * Much like {@link Formio.currentUser}, but instead automatically injects the Bearer tokens into the headers to\n     * perform a Token swap of the OAuth token which will then return the JWT token for that user.\n     *\n     * @param {Formio} formio - The Formio instance\n     * @param {string} token - An OAuth Bearer token to use for a token swap between the OAuth provider and Form.io\n     * @return {Promise<R>|*}\n     */\n    static oAuthCurrentUser(formio, token) {\n        return Formio.currentUser(formio, {\n            external: true,\n            headers: {\n                Authorization: `Bearer ${token}`\n            }\n        });\n    }\n    static oauthLogoutURI(uri, options) {\n        options = (typeof options === 'string') ? { namespace: options } : options || {};\n        const logoutURIName = `${options.namespace || Formio.namespace || 'formio'}LogoutAuthUrl`;\n        Formio.tokens[logoutURIName];\n        localStorage.setItem(logoutURIName, uri);\n        return Formio.tokens[logoutURIName];\n    }\n    /**\n     * Perform a SAML initialization.\n     *\n     * @description Typically, you would use the {@link Formio.ssoInit} method to perform this function\n     * since this method is an alias for the following.\n     *\n     * ```ts\n     * Formio.samlInit();\n     * Formio.ssoInit('saml');  // This is the exact same thing as calling Formio.samlInit\n     * ```\n     *\n     * This method will return false if the process is just starting. The code below is a typical block of code that is\n     * used to automatically trigger the SAML authentication process within your application using a Button component.\n     *\n     * ```ts\n     * if (Formio.pageQuery().saml) {\n     *   const sso = Formio.samlInit();\n     *   if (sso) {\n     *     sso.then((user) => {\n     *       // The SSO user is now loaded!\n     *       console.log(user);\n     *     });\n     *   }\n     * }\n     * ```\n     *\n     * You can then place the following code withiin the \"Custom\" action of a Button component on your form.\n     *\n     * ```ts\n     * Formio.samlInit();\n     * ```\n     *\n     * Now when you click on this button, it will start the handshake process with SAML, and once it returns, will pass\n     * a \"saml\" query parameter back to your application which will execute the code to load the current user from SAML.\n     *\n     * @param {object} options - Options to pass to the SAML initialization process.\n     * @param {string} options.relay - The URL that will be used as the authentication \"relay\" that occurs during a SAML handshake process.\n     * @return {boolean|Promise<Object>|void}\n     */\n    static samlInit(options = {}) {\n        const query = Formio.pageQuery();\n        if (query.saml) {\n            Formio.setUser(null);\n            const retVal = Formio.setToken(query.saml);\n            let uri = window.location.toString();\n            uri = uri.substring(0, uri.indexOf('?'));\n            if (window.location.hash) {\n                uri += window.location.hash;\n            }\n            window.history.replaceState({}, document.title, uri);\n            return retVal;\n        }\n        // Set the relay if not provided.\n        if (!options.relay) {\n            options.relay = window.location.href;\n        }\n        // go to the saml sso endpoint for this project.\n        const authUrl = Formio.authUrl || Formio.projectUrl;\n        window.location.href = `${authUrl}/saml/sso?relay=${encodeURI(options.relay)}`;\n        return false;\n    }\n    /**\n     * Perform an Okta Authentication process using the {@link https://developer.okta.com/code/javascript/okta_auth_sdk|Okta SDK}.\n     *\n     * @description This method does require that you first include the Okta JavaScript SDK within your application as follows.\n     *\n     * First you need to include the Okta Authentication script.\n     *\n     * ```html\n     * <script src=\"https://ok1static.oktacdn.com/assets/js/sdk/okta-auth-js/2.0.1/okta-auth-js.min.js\" type=\"text/javascript\"></script>\n     * ```\n     *\n     * Then you can call this method as follows.\n     *\n     * ```ts\n     * Formio.oktaInit();\n     * ```\n     *\n     * @param {object} options - Options that are passed directly to the {@link https://github.com/okta/okta-auth-js#configuration-reference|Okta SDK constructor}\n     * @param {constructor} options.OktaAuth - If the OktaAuth constructor is not provided global to the application, it can be provided to this method using this property.\n     * @param {Formio} options.formio - The Formio instance.\n     * @param {Array<string>} options.scopes - Scopes that are passed to the {@link https://github.com/okta/okta-auth-js#tokengetwithredirectoptions|getWithRedirect} method from the Okta SDK.\n     * @return {Promise<Object>}\n     */\n    static oktaInit(options = {}) {\n        if (typeof OktaAuth !== undefined) {\n            options.OktaAuth = OktaAuth;\n        }\n        if (typeof options.OktaAuth === undefined) {\n            const errorMessage = 'Cannot find OktaAuth. Please include the Okta JavaScript SDK within your application. See https://developer.okta.com/code/javascript/okta_auth_sdk for an example.';\n            console.warn(errorMessage);\n            return Promise.reject(errorMessage);\n        }\n        return new Promise((resolve, reject) => {\n            const Okta = options.OktaAuth;\n            delete options.OktaAuth;\n            const authClient = new Okta(options);\n            authClient.tokenManager.get('accessToken')\n                .then((accessToken) => {\n                if (accessToken) {\n                    resolve(Formio.oAuthCurrentUser(options.formio, accessToken.accessToken));\n                }\n                else if (location.hash) {\n                    authClient.token.parseFromUrl()\n                        .then((token) => {\n                        authClient.tokenManager.add('accessToken', token);\n                        resolve(Formio.oAuthCurrentUser(options.formio, token.accessToken));\n                    })\n                        .catch((err) => {\n                        console.warn(err);\n                        reject(err);\n                    });\n                }\n                else {\n                    authClient.token.getWithRedirect({\n                        responseType: 'token',\n                        scopes: options.scopes\n                    });\n                    resolve(false);\n                }\n            })\n                .catch((error) => {\n                reject(error);\n            });\n        });\n    }\n    /**\n     * A common static method to trigger any SSO processes. This method is really just an alias for other static methods.\n     *\n     * @param {('saml'|'okta')} type - The type of SSO to trigger. 'saml' is an alias for {@link Formio.samlInit}, and 'okta' is an alias for {@link Formio.oktaInit}.\n     * @param {object} options - Options to pass to the specific sso methods\n     * @return {*|Promise<Object>|boolean|void}\n     */\n    static ssoInit(type, options = {}) {\n        switch (type) {\n            case 'saml':\n                return Formio.samlInit(options);\n            case 'okta':\n                return Formio.oktaInit(options);\n            default:\n                console.warn('Unknown SSO type');\n                return Promise.reject('Unknown SSO type');\n        }\n    }\n    /**\n     * Lazy load a remote library dependency.\n     *\n     * @description This is useful for components that wish to lazy load a required library\n     * by adding that library to the <scripts> section of the HTML webpage, and then provide a promise that will resolve\n     * when the library becomes available for use.\n     *\n     * @example Load Google Maps API.\n     * ```ts\n     * Formio.requireLibrary('googleMaps', 'google.maps.Map', 'https://maps.googleapis.com/maps/api/js?key=YOUR_API_KEY&callback=initMap', true).then(() => {\n     *   // Once the promise resolves, the following can now be used within your application.\n     *   const map = new google.maps.Map(document.getElementById(\"map\"), {...});\n     * });\n     * ```\n     *\n     * @param {string} name - The internal name to give to the library you are loading. This is useful for caching the library for later use.\n     * @param {string} property - The name of the global property that will be added to the global namespace once the library has been loaded. This is used to check to see if the property exists before resolving the promise that the library is ready for use.\n     * @param {string} src - The URL of the library to lazy load.\n     * @param {boolean} polling - Determines if polling should be used to determine if they library is ready to use. If set to false, then it will rely on a global callback called ${name}Callback where \"name\" is the first property passed to this method. When this is called, that will indicate when the library is ready. In most cases, you will want to pass true to this parameter to initiate a polling method to check for the library availability in the global context.\n     * @return {Promise<object>} - A promise that will resolve when the plugin is ready to be used.\n     */\n    static requireLibrary(name, property, src, polling = false, onload) {\n        if (!Formio.libraries.hasOwnProperty(name)) {\n            Formio.libraries[name] = {};\n            Formio.libraries[name].ready = new Promise((resolve, reject) => {\n                Formio.libraries[name].resolve = resolve;\n                Formio.libraries[name].reject = reject;\n            });\n            const callbackName = `${name}Callback`;\n            if (!polling && !window[callbackName]) {\n                window[callbackName] = () => Formio.libraries[name].resolve();\n            }\n            // See if the plugin already exists.\n            const plugin = (0, lodash_1.get)(window, property);\n            if (plugin) {\n                Formio.libraries[name].resolve(plugin);\n            }\n            else {\n                src = Array.isArray(src) ? src : [src];\n                src.forEach((lib) => {\n                    let attrs = {};\n                    let elementType = '';\n                    if (typeof lib === 'string') {\n                        lib = {\n                            type: 'script',\n                            src: lib,\n                        };\n                    }\n                    switch (lib.type) {\n                        case 'script':\n                            elementType = 'script';\n                            attrs = {\n                                src: lib.src,\n                                type: 'text/javascript',\n                                defer: true,\n                                async: true,\n                                referrerpolicy: 'origin',\n                            };\n                            break;\n                        case 'styles':\n                            elementType = 'link';\n                            attrs = {\n                                href: lib.src,\n                                rel: 'stylesheet',\n                            };\n                            break;\n                    }\n                    // Add the script to the top of the page.\n                    const element = document.createElement(elementType);\n                    if (element.setAttribute) {\n                        for (const attr in attrs) {\n                            element.setAttribute(attr, attrs[attr]);\n                        }\n                    }\n                    if (onload) {\n                        element.addEventListener('load', () => {\n                            Formio.libraries[name].loaded = true;\n                            onload(Formio.libraries[name].ready);\n                        });\n                    }\n                    const { head } = document;\n                    if (head) {\n                        head.appendChild(element);\n                    }\n                });\n                // if no callback is provided, then check periodically for the script.\n                if (polling) {\n                    const interval = setInterval(() => {\n                        const plugin = (0, lodash_1.get)(window, property);\n                        if (plugin) {\n                            clearInterval(interval);\n                            Formio.libraries[name].resolve(plugin);\n                        }\n                    }, 200);\n                }\n            }\n        }\n        const lib = Formio.libraries[name];\n        return onload && lib.loaded ? onload(lib.ready) : lib.ready;\n    }\n    /**\n     * Determines if a lazy loaded library is ready to be used.\n     *\n     * @description Example: Let's assume that the example provided at {@link Formio.requireLibrary} was used elsewhere in your application.\n     * You could now use the following within a separate place that will also resolve once the library is ready to be used.\n     *\n     * ```js\n     * Formio.libraryReady('googleMaps').then(() => {\n     *   // Once the promise resolves, the following can now be used within your application.\n     *   const map = new google.maps.Map(document.getElementById(\"map\"), {...});\n     * });\n     * ```\n     *\n     * @param {string} name - The name of the library to check.\n     * @return {Promise<object>} - A promise that will resolve when the library is ready to be used.\n     */\n    static libraryReady(name) {\n        if (Formio.libraries.hasOwnProperty(name) &&\n            Formio.libraries[name].ready) {\n            return Formio.libraries[name].ready;\n        }\n        return Promise.reject(`${name} library was not required.`);\n    }\n    /**\n     * Clones the response from the API so that it cannot be mutated.\n     *\n     * @param response\n     */\n    static cloneResponse(response) {\n        const copy = (0, lodash_1.fastCloneDeep)(response);\n        if (Array.isArray(response)) {\n            copy.skip = response.skip;\n            copy.limit = response.limit;\n            copy.serverCount = response.serverCount;\n        }\n        return copy;\n    }\n    /**\n     * Sets the project path type.\n     *\n     * @param type\n     */\n    static setPathType(type) {\n        if (typeof type === 'string') {\n            Formio.pathType = type;\n        }\n    }\n    /**\n     * Gets the project path type.\n     */\n    static getPathType() {\n        return Formio.pathType;\n    }\n}\nexports.Formio = Formio;\n/**\n * The base API url of the Form.io Platform. Example: https://api.form.io\n */\nFormio.baseUrl = 'https://api.form.io';\n/**\n * The project API url of the Form.io Project. Example: https://examples.form.io\n */\nFormio.projectUrl = '';\n/**\n * The project url to use for Authentication.\n */\nFormio.authUrl = '';\n/**\n * Set to true if the project url has been established with ```Formio.setProjectUrl()```\n */\nFormio.projectUrlSet = false;\n/**\n * The Form.io API Cache. This ensures that requests to the same API endpoint are cached.\n */\nFormio.cache = {};\n/**\n * The namespace used to save the Form.io Token's and variables within an application.\n */\nFormio.namespace = '';\n/**\n * Handles events fired within this SDK library.\n */\nFormio.events = new eventemitter3_1.default();\n/**\n * Stores all of the libraries lazy loaded with ```Formio.requireLibrary``` method.\n */\nFormio.libraries = {};\n/**\n * A direct interface to the Form.io fetch polyfill.\n */\nFormio.fetch = fetch;\n/**\n * A direct interface to the Form.io fetch Headers polyfill.\n */\nFormio.Headers = Headers;\n/**\n * All of the auth tokens for this session.\n */\nFormio.tokens = {};\n/**\n * The version of this library.\n */\nFormio.version = '---VERSION---';\n// Add Plugin methods.\nFormio.plugins = Plugins_1.default.plugins;\nFormio.deregisterPlugin = Plugins_1.default.deregisterPlugin;\nFormio.registerPlugin = Plugins_1.default.registerPlugin;\nFormio.getPlugin = Plugins_1.default.getPlugin;\nFormio.pluginWait = Plugins_1.default.pluginWait;\nFormio.pluginGet = Plugins_1.default.pluginGet;\nFormio.pluginAlter = Plugins_1.default.pluginAlter;\n// Adds Formio to the Plugins Interface.\nPlugins_1.default.Formio = Formio;\n\n\n//# sourceURL=webpack://@formio/core/./src/sdk/Formio.ts?");

/***/ }),

/***/ "./src/sdk/Plugins.ts":
/*!****************************!*\
  !*** ./src/sdk/Plugins.ts ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst lodash_1 = __webpack_require__(/*! @formio/lodash */ \"./node_modules/@formio/lodash/lib/index.js\");\n/**\n * The Form.io Plugins allow external systems to \"hook\" into the default behaviors of the JavaScript SDK.\n */\nclass Plugins {\n    /**\n     * Returns the plugin identity.\n     *\n     * @param value\n     */\n    static identity(value) {\n        return value;\n    }\n    /**\n     * De-registers a plugin.\n     * @param plugin The plugin you wish to deregister.\n     */\n    static deregisterPlugin(plugin) {\n        const beforeLength = Plugins.plugins.length;\n        Plugins.plugins = Plugins.plugins.filter((p) => {\n            if (p !== plugin && p.__name !== plugin) {\n                return true;\n            }\n            (p.deregister || lodash_1.noop).call(plugin, Plugins.Formio);\n            return false;\n        });\n        return beforeLength !== Plugins.plugins.length;\n    }\n    /**\n     * Registers a new plugin.\n     *\n     * @param plugin The Plugin object.\n     * @param name The name of the plugin you wish to register.\n     */\n    static registerPlugin(plugin, name) {\n        Plugins.plugins.push(plugin);\n        Plugins.plugins.sort((a, b) => (b.priority || 0) - (a.priority || 0));\n        plugin.__name = name;\n        (plugin.init || lodash_1.noop).call(plugin, Plugins.Formio);\n    }\n    /**\n     * Returns a plugin provided the name of the plugin.\n     * @param name The name of the plugin you would like to get.\n     */\n    static getPlugin(name) {\n        for (const plugin of Plugins.plugins) {\n            if (plugin.__name === name) {\n                return plugin;\n            }\n        }\n        return null;\n    }\n    /**\n     * Wait for a plugin function to complete.\n     * @param pluginFn - A function within the plugin.\n     * @param args\n     */\n    static pluginWait(pluginFn, ...args) {\n        return Promise.all(Plugins.plugins.map((plugin) => (plugin[pluginFn] || lodash_1.noop).call(plugin, ...args)));\n    }\n    /**\n     * Gets a value from a Plugin\n     * @param pluginFn\n     * @param args\n     */\n    static pluginGet(pluginFn, ...args) {\n        const callPlugin = (index) => {\n            const plugin = Plugins.plugins[index];\n            if (!plugin) {\n                return Promise.resolve(null);\n            }\n            return Promise.resolve((plugin[pluginFn] || lodash_1.noop).call(plugin, ...args))\n                .then((result) => {\n                if (!(0, lodash_1.isNil)(result)) {\n                    return result;\n                }\n                return callPlugin(index + 1);\n            });\n        };\n        return callPlugin(0);\n    }\n    /**\n     * Allows a Plugin to alter the behavior of the JavaScript library.\n     *\n     * @param pluginFn\n     * @param value\n     * @param args\n     */\n    static pluginAlter(pluginFn, value, ...args) {\n        return Plugins.plugins.reduce((value, plugin) => (plugin[pluginFn] || Plugins.identity)(value, ...args), value);\n    }\n}\n/**\n * An array of Form.io Plugins.\n */\nPlugins.plugins = [];\nexports[\"default\"] = Plugins;\n\n\n//# sourceURL=webpack://@formio/core/./src/sdk/Plugins.ts?");

/***/ }),

/***/ "./src/sdk/index.ts":
/*!**************************!*\
  !*** ./src/sdk/index.ts ***!
  \**************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Formio = void 0;\nvar Formio_1 = __webpack_require__(/*! ./Formio */ \"./src/sdk/Formio.ts\");\nObject.defineProperty(exports, \"Formio\", ({ enumerable: true, get: function () { return Formio_1.Formio; } }));\n\n\n//# sourceURL=webpack://@formio/core/./src/sdk/index.ts?");

/***/ }),

/***/ "./src/utils/Evaluator.ts":
/*!********************************!*\
  !*** ./src/utils/Evaluator.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Evaluator = exports.BaseEvaluator = void 0;\nconst _ = __importStar(__webpack_require__(/*! @formio/lodash */ \"./node_modules/@formio/lodash/lib/index.js\"));\n// BaseEvaluator is for extending.\nclass BaseEvaluator {\n    static evaluator(func, ...params) {\n        if (Evaluator.noeval) {\n            console.warn('No evaluations allowed for this renderer.');\n            return _.noop;\n        }\n        if (typeof func === 'function') {\n            return func;\n        }\n        if (typeof params[0] === 'object') {\n            params = _.keys(params[0]);\n        }\n        return new Function(...params, func);\n    }\n    ;\n    static interpolateString(rawTemplate, data, options = {}) {\n        return rawTemplate.replace(/({{\\s*(.*?)\\s*}})/g, (match, $1, $2) => {\n            // If this is a function call and we allow evals.\n            if ($2.indexOf('(') !== -1) {\n                return $2.replace(/([^\\(]+)\\(([^\\)]+)\\s*\\);?/, (evalMatch, funcName, args) => {\n                    funcName = _.trim(funcName);\n                    const func = _.get(data, funcName);\n                    if (func) {\n                        if (args) {\n                            args = args.split(',').map((arg) => {\n                                arg = _.trim(arg);\n                                if ((arg.indexOf('\"') === 0) || (arg.indexOf(\"'\") === 0)) {\n                                    return arg.substring(1, arg.length - 1);\n                                }\n                                return _.get(data, arg);\n                            });\n                        }\n                        return Evaluator.evaluate(func, args, '', false, data, options);\n                    }\n                    return '';\n                });\n            }\n            else {\n                let dataPath = $2;\n                if ($2.indexOf('?') !== -1) {\n                    dataPath = $2.replace(/\\?\\./g, '.');\n                }\n                // Allow for conditional values.\n                const parts = dataPath.split('||').map((item) => item.trim());\n                let value = '';\n                let path = '';\n                for (let i = 0; i < parts.length; i++) {\n                    path = parts[i];\n                    value = _.get(data, path);\n                    if (value) {\n                        break;\n                    }\n                }\n                if (options.data) {\n                    _.set(options.data, path, value);\n                }\n                return value;\n            }\n        });\n    }\n    static interpolate(rawTemplate, data, options = {}) {\n        if (typeof rawTemplate === 'function') {\n            try {\n                return rawTemplate(data);\n            }\n            catch (err) {\n                console.warn('Error interpolating template', err, data);\n                return err.message;\n            }\n        }\n        return Evaluator.interpolateString(String(rawTemplate), data, options);\n    }\n    ;\n    /**\n     * Evaluate a method.\n     *\n     * @param func\n     * @param args\n     * @return {*}\n     */\n    static evaluate(func, args = {}, ret = '', interpolate = false, context = {}, options = {}) {\n        let returnVal = null;\n        options = _.isObject(options) ? options : { noeval: options };\n        const component = args.component ? args.component : { key: 'unknown' };\n        if (!args.form && args.instance) {\n            args.form = _.get(args.instance, 'root._form', {});\n        }\n        const componentKey = component.key;\n        if (typeof func === 'string') {\n            if (ret) {\n                func += `;return ${ret}`;\n            }\n            if (interpolate) {\n                func = BaseEvaluator.interpolate(func, args, options);\n            }\n            try {\n                if (Evaluator.noeval || options.noeval) {\n                    func = _.noop;\n                }\n                else {\n                    func = Evaluator.evaluator(func, args, context);\n                }\n                args = _.values(args);\n            }\n            catch (err) {\n                console.warn(`An error occured within the custom function for ${componentKey}`, err);\n                returnVal = null;\n                func = false;\n            }\n        }\n        if (typeof func === 'function') {\n            try {\n                returnVal = Evaluator.execute(func, args, context, options);\n            }\n            catch (err) {\n                returnVal = null;\n                console.warn(`An error occured within custom function for ${componentKey}`, err);\n            }\n        }\n        else if (func) {\n            console.warn(`Unknown function type for ${componentKey}`);\n        }\n        return returnVal;\n    }\n    /**\n     * Execute a function.\n     *\n     * @param func\n     * @param args\n     * @returns\n     */\n    static execute(func, args, context = {}, options = {}) {\n        options = _.isObject(options) ? options : { noeval: options };\n        if (Evaluator.noeval || options.noeval) {\n            console.warn('No evaluations allowed for this renderer.');\n            return;\n        }\n        return Array.isArray(args) ? func.apply(context, args) : func.call(context, args);\n    }\n    ;\n}\nexports.BaseEvaluator = BaseEvaluator;\nBaseEvaluator.templateSettings = {\n    interpolate: /{{([\\s\\S]+?)}}/g,\n    evaluate: /\\{%([\\s\\S]+?)%\\}/g,\n    escape: /\\{\\{\\{([\\s\\S]+?)\\}\\}\\}/g\n};\nBaseEvaluator.noeval = false;\n// The extendable evaluator\nclass Evaluator extends BaseEvaluator {\n    /**\n     * Allow external modules the ability to extend the Evaluator.\n     * @param evaluator\n     */\n    static registerEvaluator(evaluator) {\n        Object.keys(evaluator).forEach((key) => {\n            Evaluator[key] = evaluator[key];\n        });\n    }\n}\nexports.Evaluator = Evaluator;\n\n\n//# sourceURL=webpack://@formio/core/./src/utils/Evaluator.ts?");

/***/ }),

/***/ "./src/utils/formUtil.ts":
/*!*******************************!*\
  !*** ./src/utils/formUtil.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.uniqueName = exports.guid = exports.flattenComponents = exports.eachComponent = void 0;\nconst Evaluator_1 = __webpack_require__(/*! ./Evaluator */ \"./src/utils/Evaluator.ts\");\nconst lodash_1 = __webpack_require__(/*! @formio/lodash */ \"./node_modules/@formio/lodash/lib/index.js\");\n/**\n * Iterate through each component within a form.\n *\n * @param {Object} components\n *   The components to iterate.\n * @param {Function} fn\n *   The iteration function to invoke for each component.\n * @param {Boolean} includeAll\n *   Whether or not to include layout components.\n * @param {String} path\n *   The current data path of the element. Example: data.user.firstName\n * @param {Object} parent\n *   The parent object.\n */\nfunction eachComponent(components, fn, includeAll, path, parent) {\n    if (!components)\n        return;\n    path = path || '';\n    components.forEach((component) => {\n        if (!component) {\n            return;\n        }\n        const hasColumns = component.columns && Array.isArray(component.columns);\n        const hasRows = component.rows && Array.isArray(component.rows);\n        const hasComps = component.components && Array.isArray(component.components);\n        let noRecurse = false;\n        const newPath = component.key ? (path ? (`${path}.${component.key}`) : component.key) : '';\n        // Keep track of parent references.\n        if (parent) {\n            // Ensure we don't create infinite JSON structures.\n            component.parent = Object.assign({}, parent);\n            delete component.parent.components;\n            delete component.parent.componentMap;\n            delete component.parent.columns;\n            delete component.parent.rows;\n        }\n        // there's no need to add other layout components here because we expect that those would either have columns, rows or components\n        const layoutTypes = ['htmlelement', 'content'];\n        const isLayoutComponent = hasColumns || hasRows || hasComps || layoutTypes.indexOf(component.type) > -1;\n        if (includeAll || component.tree || !isLayoutComponent) {\n            noRecurse = fn(component, newPath, components);\n        }\n        const subPath = () => {\n            if (component.key &&\n                !['panel', 'table', 'well', 'columns', 'fieldset', 'tabs', 'form'].includes(component.type) &&\n                (['datagrid', 'container', 'editgrid', 'address', 'dynamicWizard'].includes(component.type) ||\n                    component.tree)) {\n                return newPath;\n            }\n            else if (component.key &&\n                component.type === 'form') {\n                return `${newPath}.data`;\n            }\n            return path;\n        };\n        if (!noRecurse) {\n            if (hasColumns) {\n                component.columns.forEach((column) => eachComponent(column.components, fn, includeAll, subPath(), parent ? component : null));\n            }\n            else if (hasRows) {\n                component.rows.forEach((row) => {\n                    if (Array.isArray(row)) {\n                        row.forEach((column) => eachComponent(column.components, fn, includeAll, subPath(), parent ? component : null));\n                    }\n                });\n            }\n            else if (hasComps) {\n                eachComponent(component.components, fn, includeAll, subPath(), parent ? component : null);\n            }\n        }\n    });\n}\nexports.eachComponent = eachComponent;\n/**\n * Flatten the form components for data manipulation.\n *\n * @param {Object} components\n *   The components to iterate.\n * @param {Boolean} includeAll\n *   Whether or not to include layout components.\n *\n * @returns {Object}\n *   The flattened components map.\n */\nfunction flattenComponents(components, includeAll) {\n    const flattened = {};\n    eachComponent(components, (component, path) => {\n        flattened[path] = component;\n    }, includeAll);\n    return flattened;\n}\nexports.flattenComponents = flattenComponents;\nfunction guid() {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n        const r = Math.random() * 16 | 0;\n        const v = c === 'x'\n            ? r\n            : (r & 0x3 | 0x8);\n        return v.toString(16);\n    });\n}\nexports.guid = guid;\n/**\n * Make a filename guaranteed to be unique.\n * @param name\n * @param template\n * @param evalContext\n * @returns {string}\n */\nfunction uniqueName(name, template, evalContext) {\n    template = template || '{{fileName}}-{{guid}}';\n    //include guid in template anyway, to prevent overwriting issue if filename matches existing file\n    if (!template.includes('{{guid}}')) {\n        template = `${template}-{{guid}}`;\n    }\n    const parts = name.split('.');\n    let fileName = parts.slice(0, parts.length - 1).join('.');\n    const extension = parts.length > 1\n        ? `.${(0, lodash_1.last)(parts)}`\n        : '';\n    //allow only 100 characters from original name to avoid issues with filename length restrictions\n    fileName = fileName.substr(0, 100);\n    evalContext = Object.assign(evalContext || {}, {\n        fileName,\n        guid: guid()\n    });\n    //only letters, numbers, dots, dashes, underscores and spaces are allowed. Anything else will be replaced with dash\n    const uniqueName = `${Evaluator_1.Evaluator.interpolate(template, evalContext)}${extension}`.replace(/[^0-9a-zA-Z.\\-_ ]/g, '-');\n    return uniqueName;\n}\nexports.uniqueName = uniqueName;\n\n\n//# sourceURL=webpack://@formio/core/./src/utils/formUtil.ts?");

/***/ }),

/***/ "./src/utils/jwtDecode.ts":
/*!********************************!*\
  !*** ./src/utils/jwtDecode.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\n// copied from https://github.com/auth0/jwt-decode\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.jwtDecode = void 0;\nfunction b64DecodeUnicode(str) {\n    return decodeURIComponent(atob(str).replace(/(.)/g, function (m, p) {\n        let code = p.charCodeAt(0).toString(16).toUpperCase();\n        if (code.length < 2) {\n            code = '0' + code;\n        }\n        return '%' + code;\n    }));\n}\nfunction b64UrlDecode(str) {\n    let output = str.replace(/-/g, '+').replace(/_/g, '/');\n    switch (output.length % 4) {\n        case 0:\n            break;\n        case 2:\n            output += '==';\n            break;\n        case 3:\n            output += '=';\n            break;\n        default:\n            throw new Error('base64 string is not of the correct length');\n    }\n    try {\n        return b64DecodeUnicode(output);\n    }\n    catch (err) {\n        return atob(output);\n    }\n}\nfunction jwtDecode(token, options = {}) {\n    if (typeof token !== 'string') {\n        throw new Error('Invalid token specified: must be a string');\n    }\n    const pos = options.header === true ? 0 : 1;\n    const part = token.split('.')[pos];\n    if (typeof part !== 'string') {\n        throw new Error('Invalid token specified: missing part #' + (pos + 1));\n    }\n    let decoded;\n    try {\n        decoded = b64UrlDecode(part);\n    }\n    catch (e) {\n        throw new Error('Invalid token specified: invalid base64 for part #' +\n            (pos + 1) +\n            ' (' +\n            e.message +\n            ')');\n    }\n    try {\n        return JSON.parse(decoded);\n    }\n    catch (e) {\n        throw new Error('Invalid token specified: invalid json for part #' +\n            (pos + 1) +\n            ' (' +\n            e.message +\n            ')');\n    }\n}\nexports.jwtDecode = jwtDecode;\n\n\n//# sourceURL=webpack://@formio/core/./src/utils/jwtDecode.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/sdk/index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});