/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(self, function() {
return /******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@formio/lodash/lib/array.js":
/*!**************************************************!*\
  !*** ./node_modules/@formio/lodash/lib/array.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.intersection = exports.map = exports.head = exports.last = exports.filter = exports.findEach = exports.matches = exports.findIndex = exports.find = exports.each = exports.dropRight = exports.drop = exports.difference = exports.concat = exports.compact = exports.chunk = void 0;\nvar lang_1 = __webpack_require__(/*! ./lang */ \"./node_modules/@formio/lodash/lib/lang.js\");\nvar object_1 = __webpack_require__(/*! ./object */ \"./node_modules/@formio/lodash/lib/object.js\");\n// https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_chunk\nfunction chunk(input, size) {\n    return input.reduce(function (arr, item, idx) {\n        return idx % size === 0\n            ? __spreadArray(__spreadArray([], arr, true), [[item]], false) : __spreadArray(__spreadArray([], arr.slice(0, -1), true), [__spreadArray(__spreadArray([], arr.slice(-1)[0], true), [item], false)], false);\n    }, []);\n}\nexports.chunk = chunk;\n;\n// https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_compact\nfunction compact(input) {\n    return input.filter(Boolean);\n}\nexports.compact = compact;\n/**\n * @link https://lodash.com/docs/4.17.15#concat\n * @param input\n * @param args\n * @returns\n */\nfunction concat(input) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    return input.concat.apply(input, args);\n}\nexports.concat = concat;\n// https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_difference\nfunction difference() {\n    var arrays = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        arrays[_i] = arguments[_i];\n    }\n    return arrays.reduce(function (a, b) {\n        return a.filter(function (value) {\n            return !b.includes(value);\n        });\n    });\n}\nexports.difference = difference;\n// https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_drop\nfunction drop(arr, index) {\n    if (index === void 0) { index = 1; }\n    return (index > 0) ? arr.slice(index) : arr;\n}\nexports.drop = drop;\n// https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_dropright\nfunction dropRight(arr, index) {\n    if (index === void 0) { index = 1; }\n    return (index > 0) ? arr.slice(0, -index) : arr;\n}\nexports.dropRight = dropRight;\n/**\n * Iterate through a collection or array.\n * @param collection\n * @param _each\n */\nfunction each(collection, _each) {\n    var isArray = Array.isArray(collection);\n    for (var i in collection) {\n        if (collection.hasOwnProperty(i)) {\n            if (_each(collection[i], isArray ? Number(i) : i) === true) {\n                break;\n            }\n            ;\n        }\n    }\n}\nexports.each = each;\n/**\n * Perform a find operation.\n * @param arr\n * @param query\n */\nfunction find(arr, query, findIndex) {\n    if (findIndex === void 0) { findIndex = false; }\n    if (!arr) {\n        return undefined;\n    }\n    if (Array.isArray(arr) && typeof query === 'function') {\n        return findIndex ? arr.findIndex(query) : arr.find(query);\n    }\n    var found = undefined;\n    var foundIndex = 0;\n    findEach(arr, query, function (item, index) {\n        found = item;\n        foundIndex = index;\n        return true;\n    });\n    return findIndex ? foundIndex : found;\n}\nexports.find = find;\n/**\n * Find an index.\n *\n * @param arr\n * @param query\n * @returns\n */\nfunction findIndex(arr, query) {\n    return find(arr, query, true);\n}\nexports.findIndex = findIndex;\n/**\n * Returns a function to perform matches.\n * @param query\n * @returns\n */\nfunction matches(query) {\n    var keys = [];\n    var compare = {};\n    if (typeof query === 'string') {\n        keys = [query];\n        compare[query] = true;\n    }\n    else {\n        keys = Object.keys(query);\n        compare = query;\n    }\n    return function (comp) {\n        return (0, lang_1.isEqual)((0, object_1.pick)(comp, keys), compare);\n    };\n}\nexports.matches = matches;\n/**\n * Perform a find operation on each item in an array.\n * @param arr\n * @param query\n * @param fn\n */\nfunction findEach(arr, query, fn) {\n    each(arr, function (item, index) {\n        if (matches(query)(item)) {\n            if (fn(item, index) === true) {\n                return true;\n            }\n        }\n    });\n}\nexports.findEach = findEach;\n/**\n * Perform a filter operation.\n * @param arr\n * @param fn\n */\nfunction filter(arr, fn) {\n    if (!arr) {\n        return [];\n    }\n    if (!fn) {\n        fn = function (val) { return !!val; };\n    }\n    if (Array.isArray(arr) && typeof fn === 'function') {\n        return arr.filter(fn);\n    }\n    var found = [];\n    findEach(arr, fn, function (item, index) {\n        found.push(item);\n        if (Array.isArray(item)) {\n            arr.splice(index, 1);\n        }\n        else {\n            delete arr[index];\n        }\n    });\n    return found;\n}\nexports.filter = filter;\n/**\n * Get the last item in an array.\n * @param arr\n */\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\nexports.last = last;\n/**\n * https://lodash.com/docs/4.17.15#head\n * @param arr\n * @returns\n */\nfunction head(arr) {\n    return arr[0];\n}\nexports.head = head;\n/**\n * https://lodash.com/docs/4.17.15#map\n * @param arr\n * @param fn\n * @returns\n */\nfunction map(arr, fn) {\n    return arr.map(fn);\n}\nexports.map = map;\n/**\n * Get the intersection of two objects.\n * @param a\n * @param b\n */\nfunction intersection(a, b) {\n    return a.filter(function (value) { return b.includes(value); });\n}\nexports.intersection = intersection;\n\n\n//# sourceURL=webpack://@formio/core/./node_modules/@formio/lodash/lib/array.js?");

/***/ }),

/***/ "./node_modules/@formio/lodash/lib/function.js":
/*!*****************************************************!*\
  !*** ./node_modules/@formio/lodash/lib/function.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.debounce = void 0;\n/**\n * Debounc the call of a function for a given amount of time.\n *\n * @param func\n * @param wait\n * @returns\n */\nfunction debounce(func, wait) {\n    if (wait === void 0) { wait = 100; }\n    var timeout;\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (timeout) {\n            clearTimeout(timeout);\n        }\n        timeout = setTimeout(function () {\n            timeout = null;\n            func.apply(void 0, args);\n        }, wait);\n    };\n}\nexports.debounce = debounce;\n\n\n//# sourceURL=webpack://@formio/core/./node_modules/@formio/lodash/lib/function.js?");

/***/ }),

/***/ "./node_modules/@formio/lodash/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@formio/lodash/lib/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.chain = void 0;\nvar ArrayFunctions = __importStar(__webpack_require__(/*! ./array */ \"./node_modules/@formio/lodash/lib/array.js\"));\nvar Chainable = /** @class */ (function () {\n    function Chainable(val) {\n        this.chain = [];\n        this.currentValue = [];\n        this.currentValue = val;\n    }\n    Chainable.prototype.value = function () {\n        return this.chain.reduce(function (current, func) {\n            var _a;\n            return (_a = ArrayFunctions)[func.method].apply(_a, __spreadArray([current], func.args, false));\n        }, this.currentValue);\n    };\n    return Chainable;\n}());\nvar _loop_1 = function (method) {\n    if (ArrayFunctions.hasOwnProperty(method)) {\n        Chainable.prototype[method] = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            this.chain.push({ method: method, args: args });\n            return this;\n        };\n    }\n};\nfor (var method in ArrayFunctions) {\n    _loop_1(method);\n}\n/**\n * Create a chainable array of methods.\n * @param val\n * @returns\n */\nfunction chain(val) {\n    return new Chainable(val);\n}\nexports.chain = chain;\nexports[\"default\"] = chain;\n__exportStar(__webpack_require__(/*! ./array */ \"./node_modules/@formio/lodash/lib/array.js\"), exports);\n__exportStar(__webpack_require__(/*! ./function */ \"./node_modules/@formio/lodash/lib/function.js\"), exports);\n__exportStar(__webpack_require__(/*! ./lang */ \"./node_modules/@formio/lodash/lib/lang.js\"), exports);\n__exportStar(__webpack_require__(/*! ./math */ \"./node_modules/@formio/lodash/lib/math.js\"), exports);\n__exportStar(__webpack_require__(/*! ./object */ \"./node_modules/@formio/lodash/lib/object.js\"), exports);\n__exportStar(__webpack_require__(/*! ./string */ \"./node_modules/@formio/lodash/lib/string.js\"), exports);\n\n\n//# sourceURL=webpack://@formio/core/./node_modules/@formio/lodash/lib/index.js?");

/***/ }),

/***/ "./node_modules/@formio/lodash/lib/lang.js":
/*!*************************************************!*\
  !*** ./node_modules/@formio/lodash/lib/lang.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isRegExp = exports.isBoolean = exports.isNumber = exports.isPlainObject = exports.isObject = exports.isObjectLike = exports.isArray = exports.isNull = exports.isNil = exports.isNaN = exports.isInteger = exports.isEmpty = exports.isString = exports.isEqual = exports.noop = void 0;\nvar array_1 = __webpack_require__(/*! ./array */ \"./node_modules/@formio/lodash/lib/array.js\");\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction getTag(value) {\n    if (value == null) {\n        return value === undefined ? '[object Undefined]' : '[object Null]';\n    }\n    return Object.prototype.toString.call(value);\n}\n/**\n * A no-operation function.\n */\nfunction noop() {\n    return;\n}\nexports.noop = noop;\n;\n/**\n * Determines equality of a value or complex object.\n * @param a\n * @param b\n */\nfunction isEqual(a, b) {\n    var equal = false;\n    if (a === b) {\n        return true;\n    }\n    if (a && b && (Array.isArray(a) || isObject(a)) && Object.keys(a).length === Object.keys(b).length) {\n        equal = true;\n        (0, array_1.each)(a, function (val, key) {\n            if ((Array.isArray(val) || isObject(val)) && !isEqual(b[key], val)) {\n                equal = false;\n                return true;\n            }\n            if (b[key] !== val) {\n                equal = false;\n                return true;\n            }\n        });\n    }\n    return equal;\n}\nexports.isEqual = isEqual;\nfunction isString(val) {\n    return typeof val === 'string';\n}\nexports.isString = isString;\n// https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_isempty\nfunction isEmpty(val) {\n    return [Object, Array].includes((val || {}).constructor) && !Object.entries((val || {})).length;\n}\nexports.isEmpty = isEmpty;\nfunction isInteger(val) {\n    return Number.isInteger(val);\n}\nexports.isInteger = isInteger;\nfunction isNaN(val) {\n    return Number.isNaN(val);\n}\nexports.isNaN = isNaN;\nfunction isNil(val) {\n    return val == null;\n}\nexports.isNil = isNil;\nfunction isNull(val) {\n    return val === null;\n}\nexports.isNull = isNull;\nfunction isArray(val) {\n    return Array.isArray(val);\n}\nexports.isArray = isArray;\nfunction isObjectLike(val) {\n    return typeof val === 'object' && (val !== null);\n}\nexports.isObjectLike = isObjectLike;\nfunction isObject(val) {\n    var type = typeof val;\n    return val != null && (type === 'object' || type === 'function');\n}\nexports.isObject = isObject;\nfunction isPlainObject(value) {\n    if (!isObjectLike(value) || getTag(value) != '[object Object]') {\n        return false;\n    }\n    if (Object.getPrototypeOf(value) === null) {\n        return true;\n    }\n    var proto = value;\n    while (Object.getPrototypeOf(proto) !== null) {\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(value) === proto;\n}\nexports.isPlainObject = isPlainObject;\nfunction isNumber(val) {\n    return typeof val === 'number' || (isObjectLike(val) && getTag(val) == '[object Number]');\n}\nexports.isNumber = isNumber;\nfunction isBoolean(val) {\n    return val === true || val === false || (isObjectLike(val) && getTag(val) == '[object Boolean]');\n}\nexports.isBoolean = isBoolean;\nfunction isRegExp(val) {\n    return isObjectLike(val) && getTag(val) == '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\n\n//# sourceURL=webpack://@formio/core/./node_modules/@formio/lodash/lib/lang.js?");

/***/ }),

/***/ "./node_modules/@formio/lodash/lib/math.js":
/*!*************************************************!*\
  !*** ./node_modules/@formio/lodash/lib/math.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.sumBy = exports.sum = exports.mod = exports.subtract = exports.round = exports.multiply = exports.minBy = exports.min = exports.meanBy = exports.mean = exports.maxBy = exports.max = exports.floor = exports.divide = exports.ceil = exports.add = void 0;\nvar lang_1 = __webpack_require__(/*! ./lang */ \"./node_modules/@formio/lodash/lib/lang.js\");\nvar object_1 = __webpack_require__(/*! ./object */ \"./node_modules/@formio/lodash/lib/object.js\");\nfunction mathOp(a, op, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (!precision) {\n        return op(a);\n    }\n    precision = Math.pow(10, precision);\n    return op(a * precision) / precision;\n}\nfunction compareBy(arr, fn, op) {\n    var first = arr[0];\n    if (arr.length <= 1) {\n        return first;\n    }\n    var fnString = (0, lang_1.isString)(fn);\n    return arr.slice(1).reduce(function (current, next) {\n        var currentValue = fnString ? (0, object_1.get)(current, fn) : fn(current);\n        var nextValue = fnString ? (0, object_1.get)(next, fn) : fn(next);\n        var result = op(currentValue, nextValue);\n        return (result === nextValue) ? next : current;\n    }, first);\n}\nfunction valueBy(arr, fn, op) {\n    var first = arr[0];\n    if (arr.length <= 1) {\n        return first;\n    }\n    var fnString = (0, lang_1.isString)(fn);\n    return arr.slice(1).reduce(function (current, next) { return op(current, fnString ? (0, object_1.get)(next, fn) : fn(next)); }, fnString ? (0, object_1.get)(first, fn) : fn(first));\n}\n/**\n * @link https://lodash.com/docs/4.17.15#add\n * @param augend\n * @param addend\n * @returns\n */\nfunction add(augend, addend) {\n    return augend + addend;\n}\nexports.add = add;\n/**\n * @link https://lodash.com/docs/4.17.15#ceil\n * @param num\n * @param precision\n * @returns\n */\nfunction ceil(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    return mathOp(num, Math.ceil, precision);\n}\nexports.ceil = ceil;\n/**\n * https://lodash.com/docs/4.17.15#divide\n * @param dividend\n * @param divisor\n * @returns\n */\nfunction divide(dividend, divisor) {\n    return dividend / divisor;\n}\nexports.divide = divide;\n/**\n * @link https://lodash.com/docs/4.17.15#floor\n * @param num\n * @param precision\n * @returns\n */\nfunction floor(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    return mathOp(num, Math.floor, precision);\n}\nexports.floor = floor;\n/**\n * @link https://lodash.com/docs/4.17.15#max\n * @param arr\n * @returns\n */\nfunction max(arr) {\n    return Math.max.apply(Math, arr);\n}\nexports.max = max;\n/**\n * @link https://lodash.com/docs/4.17.15#maxBy\n */\nfunction maxBy(arr, fn) {\n    return compareBy(arr, fn, Math.max);\n}\nexports.maxBy = maxBy;\n/**\n * @link https://lodash.com/docs/4.17.15#mean\n * @param arr\n * @returns\n */\nfunction mean(arr) {\n    return sum(arr) / arr.length;\n}\nexports.mean = mean;\n/**\n * @link https://lodash.com/docs/4.17.15#meanBy\n * @param arr\n * @param fn\n * @returns\n */\nfunction meanBy(arr, fn) {\n    return sumBy(arr, fn) / arr.length;\n}\nexports.meanBy = meanBy;\n/**\n * @link https://lodash.com/docs/4.17.15#min\n * @param arr\n * @returns\n */\nfunction min(arr) {\n    return Math.min.apply(Math, arr);\n}\nexports.min = min;\n/**\n * @link https://lodash.com/docs/4.17.15#minBy\n * @param arr\n * @param fn\n * @returns\n */\nfunction minBy(arr, fn) {\n    return compareBy(arr, fn, Math.min);\n}\nexports.minBy = minBy;\n/**\n * @link https://lodash.com/docs/4.17.15#multiply\n * @param multiplier\n * @param multiplicand\n * @returns\n */\nfunction multiply(multiplier, multiplicand) {\n    return multiplier * multiplicand;\n}\nexports.multiply = multiply;\n/**\n * @link https://lodash.com/docs/4.17.15#round\n * @param num\n * @param precision\n * @returns\n */\nfunction round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    return mathOp(num, Math.round, precision);\n}\nexports.round = round;\n/**\n * @link https://lodash.com/docs/4.17.15#subtract\n * @param a\n * @param b\n * @returns\n */\nfunction subtract(minuend, subtrahend) {\n    return minuend - subtrahend;\n}\nexports.subtract = subtract;\n/**\n * Perform a modulus operation between two numbers.\n * @param a\n * @param b\n * @returns\n */\nfunction mod(a, b) {\n    return a % b;\n}\nexports.mod = mod;\n/**\n * @link https://lodash.com/docs/4.17.15#sum\n * @param arr\n * @returns\n */\nfunction sum(arr) {\n    return arr.reduce(add, 0);\n}\nexports.sum = sum;\n/**\n * @link https://lodash.com/docs/4.17.15#sumBy\n * @param arr\n * @param fn\n * @returns\n */\nfunction sumBy(arr, fn) {\n    return valueBy(arr, fn, function (a, b) { return (a + b); });\n}\nexports.sumBy = sumBy;\n\n\n//# sourceURL=webpack://@formio/core/./node_modules/@formio/lodash/lib/math.js?");

/***/ }),

/***/ "./node_modules/@formio/lodash/lib/object.js":
/*!***************************************************!*\
  !*** ./node_modules/@formio/lodash/lib/object.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.pick = exports.defaults = exports.cloneDeep = exports.clone = exports.fastCloneDeep = exports.merge = exports.set = exports.has = exports.propertyOf = exports.property = exports.get = exports.pathParts = exports.values = exports.keys = void 0;\nvar lang_1 = __webpack_require__(/*! ./lang */ \"./node_modules/@formio/lodash/lib/lang.js\");\nvar array_1 = __webpack_require__(/*! ./array */ \"./node_modules/@formio/lodash/lib/array.js\");\n/**\n * Get the keys of an Object.\n * @param obj\n */\nfunction keys(obj) {\n    return Object.keys(obj);\n}\nexports.keys = keys;\n;\n/**\n * Return the values of an object or an array.\n * @param obj\n * @returns\n */\nfunction values(obj) {\n    return (0, lang_1.isArray)(obj) ? obj : Object.values(obj);\n}\nexports.values = values;\n/**\n * Retrieve the path parts provided a path string.\n * @param path\n */\nfunction pathParts(path) {\n    if (!path) {\n        return [];\n    }\n    if (path[0] === '[') {\n        path = path.replace(/^\\[([^\\]]+)\\]/, '$1');\n    }\n    return path.\n        replace(/\\[/g, '.').\n        replace(/\\]/g, '').\n        split('.');\n}\nexports.pathParts = pathParts;\n/**\n * Get the value from an object or an array provided a path.\n *\n * @param obj\n * @param path\n * @param def\n */\nfunction get(obj, path, def) {\n    var val = pathParts(path).reduce(function (o, k) { return (o || {})[k]; }, obj);\n    return (typeof def !== 'undefined' &&\n        typeof val === 'undefined') ? def : val;\n}\nexports.get = get;\nfunction property(path) {\n    return function (obj) { return get(obj, path); };\n}\nexports.property = property;\nfunction propertyOf(obj) {\n    return function (path) { return get(obj, path); };\n}\nexports.propertyOf = propertyOf;\n/**\n * Determine if a value is set.\n *\n * @param obj\n * @param path\n */\nfunction has(obj, path) {\n    return get(obj, path, undefined) !== undefined;\n}\nexports.has = has;\n/**\n * Sets the value of an item within an array or object.\n * @param obj\n * @param path\n * @param value\n */\nfunction set(obj, path, value) {\n    var parts = pathParts(path);\n    parts.reduce(function (o, k, i) {\n        if (!isNaN(Number(k))) {\n            k = Number(k);\n        }\n        if ((Array.isArray(o) ? (k >= o.length) : !o.hasOwnProperty(k)) ||\n            ((i < (parts.length - 1)) && !Array.isArray(o[k]) && !(0, lang_1.isObject)(o[k]))) {\n            o[k] = !isNaN(Number(parts[i + 1])) ? [] : {};\n        }\n        if (i === (parts.length - 1)) {\n            o[k] = value;\n        }\n        return o[k];\n    }, obj);\n    return obj;\n}\nexports.set = set;\n;\nfunction propertyIsOnObject(object, property) {\n    try {\n        return property in object;\n    }\n    catch (_) {\n        return false;\n    }\n}\n// Protects from prototype poisoning and unexpected merging up the prototype chain.\nfunction propertyIsUnsafe(target, key) {\n    return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n        && !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n            && Object.propertyIsEnumerable.call(target, key)); // and also unsafe if they're nonenumerable.\n}\n/**\n * Merge a single object.\n *\n * @param target\n * @param source\n * @returns\n */\nfunction mergeObject(target, source) {\n    for (var key in source) {\n        if (source.hasOwnProperty(key)) {\n            if (propertyIsUnsafe(target, key)) {\n                return;\n            }\n            if (propertyIsOnObject(target, key)) {\n                target[key] = merge(target[key], source[key]);\n            }\n            else {\n                target[key] = cloneDeep(source[key]);\n            }\n        }\n    }\n    return target;\n}\n/**\n * Merge two arrays.\n * @param target\n * @param source\n */\nfunction mergeArray(target, source) {\n    source.forEach(function (subSource, index) {\n        target[index] = merge(target[index], subSource);\n    });\n    return target;\n}\n/**\n * Merges a complex data object.\n *\n * @param a\n * @param b\n * @param options\n */\nfunction merge() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var first = args.shift();\n    return args.reduce(function (target, source, index) {\n        if (!target || (target === source)) {\n            return cloneDeep(source);\n        }\n        else if ((0, lang_1.isArray)(source)) {\n            // If there is no target array, then make it one.\n            if (!(0, lang_1.isArray)(target)) {\n                args[index] = target = [];\n            }\n            return mergeArray(target, source);\n        }\n        else if ((0, lang_1.isPlainObject)(source)) {\n            return mergeObject(target, source);\n        }\n        else {\n            return cloneDeep(source);\n        }\n    }, first);\n}\nexports.merge = merge;\n/**\n * Performs a fast clone deep operation.\n *\n * @param obj\n */\nfunction fastCloneDeep(obj) {\n    try {\n        return JSON.parse(JSON.stringify(obj));\n    }\n    catch (err) {\n        console.log(\"Clone Failed: \".concat(err.message));\n        return null;\n    }\n}\nexports.fastCloneDeep = fastCloneDeep;\n/**\n * Performs a shallow clone of an object.\n * @param src\n */\nfunction clone(src) {\n    if (Array.isArray(src)) { // for arrays\n        return __spreadArray([], src, true);\n    }\n    else {\n        return __assign({}, src);\n    }\n}\nexports.clone = clone;\n/**\n * Performs a recursive cloneDeep operation.\n * @param src\n * @returns\n */\nfunction cloneDeep(src) {\n    if (Array.isArray(src)) { // for arrays\n        return src.map(cloneDeep);\n    }\n    if (src === null || typeof src !== 'object') { // for primitives / functions / non-references/pointers\n        return src;\n    }\n    return Object.fromEntries(Object.entries(src).map(function (_a) {\n        var key = _a[0], val = _a[1];\n        return ([key, cloneDeep(val)]);\n    }));\n}\nexports.cloneDeep = cloneDeep;\n/**\n * Sets the defaults of an object.\n *\n * @param obj\n * @param defs\n */\nfunction defaults(obj, defs) {\n    (0, array_1.each)(defs, function (value, key) {\n        if (!obj.hasOwnProperty(key)) {\n            obj[key] = value;\n        }\n    });\n    return obj;\n}\nexports.defaults = defaults;\n/**\n * Pick an item in an object.\n * @param object\n * @param keys\n */\nfunction pick(object, keys) {\n    return keys.reduce(function (obj, key) {\n        if (object && object.hasOwnProperty(key)) {\n            obj[key] = object[key];\n        }\n        return obj;\n    }, {});\n}\nexports.pick = pick;\n;\n\n\n//# sourceURL=webpack://@formio/core/./node_modules/@formio/lodash/lib/object.js?");

/***/ }),

/***/ "./node_modules/@formio/lodash/lib/string.js":
/*!***************************************************!*\
  !*** ./node_modules/@formio/lodash/lib/string.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.endsWith = exports.trim = void 0;\n// From https://youmightnotneed.com/lodash/#trim\nfunction trim(str, c) {\n    if (c === void 0) { c = '\\\\s'; }\n    return str.replace(new RegExp(\"^([\".concat(c, \"]*)(.*?)([\").concat(c, \"]*)$\")), '$2');\n}\nexports.trim = trim;\n// Polyfill from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\nif (!String.prototype.endsWith) {\n    String.prototype.endsWith = function (search, this_len) {\n        if (this_len === undefined || this_len > this.length) {\n            this_len = this.length;\n        }\n        // @ts-ignore: Object is possibly 'undefined'\n        return this.substring(this_len - search.length, this_len) === search;\n    };\n}\n// From https://youmightnotneed.com/lodash/#endsWith\nfunction endsWith(str, c) {\n    return str.endsWith(c);\n}\nexports.endsWith = endsWith;\n\n\n//# sourceURL=webpack://@formio/core/./node_modules/@formio/lodash/lib/string.js?");

/***/ }),

/***/ "./node_modules/dayjs/dayjs.min.js":
/*!*****************************************!*\
  !*** ./node_modules/dayjs/dayjs.min.js ***!
  \*****************************************/
/***/ (function(module) {

eval("!function(t,e){ true?module.exports=e():0}(this,(function(){\"use strict\";var t=1e3,e=6e4,n=36e5,r=\"millisecond\",i=\"second\",s=\"minute\",u=\"hour\",a=\"day\",o=\"week\",f=\"month\",h=\"quarter\",c=\"year\",d=\"date\",l=\"Invalid Date\",$=/^(\\d{4})[-/]?(\\d{1,2})?[-/]?(\\d{0,2})[Tt\\s]*(\\d{1,2})?:?(\\d{1,2})?:?(\\d{1,2})?[.:]?(\\d+)?$/,y=/\\[([^\\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,M={name:\"en\",weekdays:\"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday\".split(\"_\"),months:\"January_February_March_April_May_June_July_August_September_October_November_December\".split(\"_\"),ordinal:function(t){var e=[\"th\",\"st\",\"nd\",\"rd\"],n=t%100;return\"[\"+t+(e[(n-20)%10]||e[n]||e[0])+\"]\"}},m=function(t,e,n){var r=String(t);return!r||r.length>=e?t:\"\"+Array(e+1-r.length).join(n)+t},v={s:m,z:function(t){var e=-t.utcOffset(),n=Math.abs(e),r=Math.floor(n/60),i=n%60;return(e<=0?\"+\":\"-\")+m(r,2,\"0\")+\":\"+m(i,2,\"0\")},m:function t(e,n){if(e.date()<n.date())return-t(n,e);var r=12*(n.year()-e.year())+(n.month()-e.month()),i=e.clone().add(r,f),s=n-i<0,u=e.clone().add(r+(s?-1:1),f);return+(-(r+(n-i)/(s?i-u:u-i))||0)},a:function(t){return t<0?Math.ceil(t)||0:Math.floor(t)},p:function(t){return{M:f,y:c,w:o,d:a,D:d,h:u,m:s,s:i,ms:r,Q:h}[t]||String(t||\"\").toLowerCase().replace(/s$/,\"\")},u:function(t){return void 0===t}},g=\"en\",D={};D[g]=M;var p=function(t){return t instanceof _},S=function t(e,n,r){var i;if(!e)return g;if(\"string\"==typeof e){var s=e.toLowerCase();D[s]&&(i=s),n&&(D[s]=n,i=s);var u=e.split(\"-\");if(!i&&u.length>1)return t(u[0])}else{var a=e.name;D[a]=e,i=a}return!r&&i&&(g=i),i||!r&&g},w=function(t,e){if(p(t))return t.clone();var n=\"object\"==typeof e?e:{};return n.date=t,n.args=arguments,new _(n)},O=v;O.l=S,O.i=p,O.w=function(t,e){return w(t,{locale:e.$L,utc:e.$u,x:e.$x,$offset:e.$offset})};var _=function(){function M(t){this.$L=S(t.locale,null,!0),this.parse(t)}var m=M.prototype;return m.parse=function(t){this.$d=function(t){var e=t.date,n=t.utc;if(null===e)return new Date(NaN);if(O.u(e))return new Date;if(e instanceof Date)return new Date(e);if(\"string\"==typeof e&&!/Z$/i.test(e)){var r=e.match($);if(r){var i=r[2]-1||0,s=(r[7]||\"0\").substring(0,3);return n?new Date(Date.UTC(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)):new Date(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)}}return new Date(e)}(t),this.$x=t.x||{},this.init()},m.init=function(){var t=this.$d;this.$y=t.getFullYear(),this.$M=t.getMonth(),this.$D=t.getDate(),this.$W=t.getDay(),this.$H=t.getHours(),this.$m=t.getMinutes(),this.$s=t.getSeconds(),this.$ms=t.getMilliseconds()},m.$utils=function(){return O},m.isValid=function(){return!(this.$d.toString()===l)},m.isSame=function(t,e){var n=w(t);return this.startOf(e)<=n&&n<=this.endOf(e)},m.isAfter=function(t,e){return w(t)<this.startOf(e)},m.isBefore=function(t,e){return this.endOf(e)<w(t)},m.$g=function(t,e,n){return O.u(t)?this[e]:this.set(n,t)},m.unix=function(){return Math.floor(this.valueOf()/1e3)},m.valueOf=function(){return this.$d.getTime()},m.startOf=function(t,e){var n=this,r=!!O.u(e)||e,h=O.p(t),l=function(t,e){var i=O.w(n.$u?Date.UTC(n.$y,e,t):new Date(n.$y,e,t),n);return r?i:i.endOf(a)},$=function(t,e){return O.w(n.toDate()[t].apply(n.toDate(\"s\"),(r?[0,0,0,0]:[23,59,59,999]).slice(e)),n)},y=this.$W,M=this.$M,m=this.$D,v=\"set\"+(this.$u?\"UTC\":\"\");switch(h){case c:return r?l(1,0):l(31,11);case f:return r?l(1,M):l(0,M+1);case o:var g=this.$locale().weekStart||0,D=(y<g?y+7:y)-g;return l(r?m-D:m+(6-D),M);case a:case d:return $(v+\"Hours\",0);case u:return $(v+\"Minutes\",1);case s:return $(v+\"Seconds\",2);case i:return $(v+\"Milliseconds\",3);default:return this.clone()}},m.endOf=function(t){return this.startOf(t,!1)},m.$set=function(t,e){var n,o=O.p(t),h=\"set\"+(this.$u?\"UTC\":\"\"),l=(n={},n[a]=h+\"Date\",n[d]=h+\"Date\",n[f]=h+\"Month\",n[c]=h+\"FullYear\",n[u]=h+\"Hours\",n[s]=h+\"Minutes\",n[i]=h+\"Seconds\",n[r]=h+\"Milliseconds\",n)[o],$=o===a?this.$D+(e-this.$W):e;if(o===f||o===c){var y=this.clone().set(d,1);y.$d[l]($),y.init(),this.$d=y.set(d,Math.min(this.$D,y.daysInMonth())).$d}else l&&this.$d[l]($);return this.init(),this},m.set=function(t,e){return this.clone().$set(t,e)},m.get=function(t){return this[O.p(t)]()},m.add=function(r,h){var d,l=this;r=Number(r);var $=O.p(h),y=function(t){var e=w(l);return O.w(e.date(e.date()+Math.round(t*r)),l)};if($===f)return this.set(f,this.$M+r);if($===c)return this.set(c,this.$y+r);if($===a)return y(1);if($===o)return y(7);var M=(d={},d[s]=e,d[u]=n,d[i]=t,d)[$]||1,m=this.$d.getTime()+r*M;return O.w(m,this)},m.subtract=function(t,e){return this.add(-1*t,e)},m.format=function(t){var e=this,n=this.$locale();if(!this.isValid())return n.invalidDate||l;var r=t||\"YYYY-MM-DDTHH:mm:ssZ\",i=O.z(this),s=this.$H,u=this.$m,a=this.$M,o=n.weekdays,f=n.months,h=function(t,n,i,s){return t&&(t[n]||t(e,r))||i[n].slice(0,s)},c=function(t){return O.s(s%12||12,t,\"0\")},d=n.meridiem||function(t,e,n){var r=t<12?\"AM\":\"PM\";return n?r.toLowerCase():r},$={YY:String(this.$y).slice(-2),YYYY:O.s(this.$y,4,\"0\"),M:a+1,MM:O.s(a+1,2,\"0\"),MMM:h(n.monthsShort,a,f,3),MMMM:h(f,a),D:this.$D,DD:O.s(this.$D,2,\"0\"),d:String(this.$W),dd:h(n.weekdaysMin,this.$W,o,2),ddd:h(n.weekdaysShort,this.$W,o,3),dddd:o[this.$W],H:String(s),HH:O.s(s,2,\"0\"),h:c(1),hh:c(2),a:d(s,u,!0),A:d(s,u,!1),m:String(u),mm:O.s(u,2,\"0\"),s:String(this.$s),ss:O.s(this.$s,2,\"0\"),SSS:O.s(this.$ms,3,\"0\"),Z:i};return r.replace(y,(function(t,e){return e||$[t]||i.replace(\":\",\"\")}))},m.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},m.diff=function(r,d,l){var $,y=O.p(d),M=w(r),m=(M.utcOffset()-this.utcOffset())*e,v=this-M,g=O.m(this,M);return g=($={},$[c]=g/12,$[f]=g,$[h]=g/3,$[o]=(v-m)/6048e5,$[a]=(v-m)/864e5,$[u]=v/n,$[s]=v/e,$[i]=v/t,$)[y]||v,l?g:O.a(g)},m.daysInMonth=function(){return this.endOf(f).$D},m.$locale=function(){return D[this.$L]},m.locale=function(t,e){if(!t)return this.$L;var n=this.clone(),r=S(t,e,!0);return r&&(n.$L=r),n},m.clone=function(){return O.w(this.$d,this)},m.toDate=function(){return new Date(this.valueOf())},m.toJSON=function(){return this.isValid()?this.toISOString():null},m.toISOString=function(){return this.$d.toISOString()},m.toString=function(){return this.$d.toUTCString()},M}(),T=_.prototype;return w.prototype=T,[[\"$ms\",r],[\"$s\",i],[\"$m\",s],[\"$H\",u],[\"$W\",a],[\"$M\",f],[\"$y\",c],[\"$D\",d]].forEach((function(t){T[t[1]]=function(e){return this.$g(e,t[0],t[1])}})),w.extend=function(t,e){return t.$i||(t(e,_,w),t.$i=!0),w},w.locale=S,w.isDayjs=p,w.unix=function(t){return w(1e3*t)},w.en=D[g],w.Ls=D,w.p={},w}));\n\n//# sourceURL=webpack://@formio/core/./node_modules/dayjs/dayjs.min.js?");

/***/ }),

/***/ "./node_modules/dayjs/plugin/timezone.js":
/*!***********************************************!*\
  !*** ./node_modules/dayjs/plugin/timezone.js ***!
  \***********************************************/
/***/ (function(module) {

eval("!function(t,e){ true?module.exports=e():0}(this,(function(){\"use strict\";var t={year:0,month:1,day:2,hour:3,minute:4,second:5},e={};return function(n,i,o){var r,a=function(t,n,i){void 0===i&&(i={});var o=new Date(t),r=function(t,n){void 0===n&&(n={});var i=n.timeZoneName||\"short\",o=t+\"|\"+i,r=e[o];return r||(r=new Intl.DateTimeFormat(\"en-US\",{hour12:!1,timeZone:t,year:\"numeric\",month:\"2-digit\",day:\"2-digit\",hour:\"2-digit\",minute:\"2-digit\",second:\"2-digit\",timeZoneName:i}),e[o]=r),r}(n,i);return r.formatToParts(o)},u=function(e,n){for(var i=a(e,n),r=[],u=0;u<i.length;u+=1){var f=i[u],s=f.type,m=f.value,c=t[s];c>=0&&(r[c]=parseInt(m,10))}var d=r[3],l=24===d?0:d,v=r[0]+\"-\"+r[1]+\"-\"+r[2]+\" \"+l+\":\"+r[4]+\":\"+r[5]+\":000\",h=+e;return(o.utc(v).valueOf()-(h-=h%1e3))/6e4},f=i.prototype;f.tz=function(t,e){void 0===t&&(t=r);var n=this.utcOffset(),i=this.toDate(),a=i.toLocaleString(\"en-US\",{timeZone:t}),u=Math.round((i-new Date(a))/1e3/60),f=o(a).$set(\"millisecond\",this.$ms).utcOffset(15*-Math.round(i.getTimezoneOffset()/15)-u,!0);if(e){var s=f.utcOffset();f=f.add(n-s,\"minute\")}return f.$x.$timezone=t,f},f.offsetName=function(t){var e=this.$x.$timezone||o.tz.guess(),n=a(this.valueOf(),e,{timeZoneName:t}).find((function(t){return\"timezonename\"===t.type.toLowerCase()}));return n&&n.value};var s=f.startOf;f.startOf=function(t,e){if(!this.$x||!this.$x.$timezone)return s.call(this,t,e);var n=o(this.format(\"YYYY-MM-DD HH:mm:ss:SSS\"));return s.call(n,t,e).tz(this.$x.$timezone,!0)},o.tz=function(t,e,n){var i=n&&e,a=n||e||r,f=u(+o(),a);if(\"string\"!=typeof t)return o(t).tz(a);var s=function(t,e,n){var i=t-60*e*1e3,o=u(i,n);if(e===o)return[i,e];var r=u(i-=60*(o-e)*1e3,n);return o===r?[i,o]:[t-60*Math.min(o,r)*1e3,Math.max(o,r)]}(o.utc(t,i).valueOf(),f,a),m=s[0],c=s[1],d=o(m).utcOffset(c);return d.$x.$timezone=a,d},o.tz.guess=function(){return Intl.DateTimeFormat().resolvedOptions().timeZone},o.tz.setDefault=function(t){r=t}}}));\n\n//# sourceURL=webpack://@formio/core/./node_modules/dayjs/plugin/timezone.js?");

/***/ }),

/***/ "./node_modules/dayjs/plugin/utc.js":
/*!******************************************!*\
  !*** ./node_modules/dayjs/plugin/utc.js ***!
  \******************************************/
/***/ (function(module) {

eval("!function(t,i){ true?module.exports=i():0}(this,(function(){\"use strict\";var t=\"minute\",i=/[+-]\\d\\d(?::?\\d\\d)?/g,e=/([+-]|\\d\\d)/g;return function(s,f,n){var u=f.prototype;n.utc=function(t){var i={date:t,utc:!0,args:arguments};return new f(i)},u.utc=function(i){var e=n(this.toDate(),{locale:this.$L,utc:!0});return i?e.add(this.utcOffset(),t):e},u.local=function(){return n(this.toDate(),{locale:this.$L,utc:!1})};var o=u.parse;u.parse=function(t){t.utc&&(this.$u=!0),this.$utils().u(t.$offset)||(this.$offset=t.$offset),o.call(this,t)};var r=u.init;u.init=function(){if(this.$u){var t=this.$d;this.$y=t.getUTCFullYear(),this.$M=t.getUTCMonth(),this.$D=t.getUTCDate(),this.$W=t.getUTCDay(),this.$H=t.getUTCHours(),this.$m=t.getUTCMinutes(),this.$s=t.getUTCSeconds(),this.$ms=t.getUTCMilliseconds()}else r.call(this)};var a=u.utcOffset;u.utcOffset=function(s,f){var n=this.$utils().u;if(n(s))return this.$u?0:n(this.$offset)?a.call(this):this.$offset;if(\"string\"==typeof s&&(s=function(t){void 0===t&&(t=\"\");var s=t.match(i);if(!s)return null;var f=(\"\"+s[0]).match(e)||[\"-\",0,0],n=f[0],u=60*+f[1]+ +f[2];return 0===u?0:\"+\"===n?u:-u}(s),null===s))return this;var u=Math.abs(s)<=16?60*s:s,o=this;if(f)return o.$offset=u,o.$u=0===s,o;if(0!==s){var r=this.$u?this.toDate().getTimezoneOffset():-1*this.utcOffset();(o=this.local().add(u+r,t)).$offset=u,o.$x.$localOffset=r}else o=this.utc();return o};var h=u.format;u.format=function(t){var i=t||(this.$u?\"YYYY-MM-DDTHH:mm:ss[Z]\":\"\");return h.call(this,i)},u.valueOf=function(){var t=this.$utils().u(this.$offset)?0:this.$offset+(this.$x.$localOffset||this.$d.getTimezoneOffset());return this.$d.valueOf()-6e4*t},u.isUTC=function(){return!!this.$u},u.toISOString=function(){return this.toDate().toISOString()},u.toString=function(){return this.toDate().toUTCString()};var l=u.toDate;u.toDate=function(t){return\"s\"===t&&this.$offset?n(this.format(\"YYYY-MM-DD HH:mm:ss:SSS\")).toDate():l.call(this)};var c=u.diff;u.diff=function(t,i,e){if(t&&this.$u===t.$u)return c.call(this,t,i,e);var s=this.local(),f=n(t).local();return c.call(s,f,i,e)}}}));\n\n//# sourceURL=webpack://@formio/core/./node_modules/dayjs/plugin/utc.js?");

/***/ }),

/***/ "./node_modules/dompurify/dist/purify.js":
/*!***********************************************!*\
  !*** ./node_modules/dompurify/dist/purify.js ***!
  \***********************************************/
/***/ (function(module) {

eval("/*! @license DOMPurify 3.0.3 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.0.3/LICENSE */\n\n(function (global, factory) {\n   true ? module.exports = factory() :\n  0;\n})(this, (function () { 'use strict';\n\n  const {\n    entries,\n    setPrototypeOf,\n    isFrozen,\n    getPrototypeOf,\n    getOwnPropertyDescriptor\n  } = Object;\n  let {\n    freeze,\n    seal,\n    create\n  } = Object; // eslint-disable-line import/no-mutable-exports\n\n  let {\n    apply,\n    construct\n  } = typeof Reflect !== 'undefined' && Reflect;\n\n  if (!apply) {\n    apply = function apply(fun, thisValue, args) {\n      return fun.apply(thisValue, args);\n    };\n  }\n\n  if (!freeze) {\n    freeze = function freeze(x) {\n      return x;\n    };\n  }\n\n  if (!seal) {\n    seal = function seal(x) {\n      return x;\n    };\n  }\n\n  if (!construct) {\n    construct = function construct(Func, args) {\n      return new Func(...args);\n    };\n  }\n\n  const arrayForEach = unapply(Array.prototype.forEach);\n  const arrayPop = unapply(Array.prototype.pop);\n  const arrayPush = unapply(Array.prototype.push);\n  const stringToLowerCase = unapply(String.prototype.toLowerCase);\n  const stringToString = unapply(String.prototype.toString);\n  const stringMatch = unapply(String.prototype.match);\n  const stringReplace = unapply(String.prototype.replace);\n  const stringIndexOf = unapply(String.prototype.indexOf);\n  const stringTrim = unapply(String.prototype.trim);\n  const regExpTest = unapply(RegExp.prototype.test);\n  const typeErrorCreate = unconstruct(TypeError);\n  function unapply(func) {\n    return function (thisArg) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      return apply(func, thisArg, args);\n    };\n  }\n  function unconstruct(func) {\n    return function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return construct(func, args);\n    };\n  }\n  /* Add properties to a lookup table */\n\n  function addToSet(set, array, transformCaseFunc) {\n    var _transformCaseFunc;\n\n    transformCaseFunc = (_transformCaseFunc = transformCaseFunc) !== null && _transformCaseFunc !== void 0 ? _transformCaseFunc : stringToLowerCase;\n\n    if (setPrototypeOf) {\n      // Make 'in' and truthy checks like Boolean(set.constructor)\n      // independent of any properties defined on Object.prototype.\n      // Prevent prototype setters from intercepting set as a this value.\n      setPrototypeOf(set, null);\n    }\n\n    let l = array.length;\n\n    while (l--) {\n      let element = array[l];\n\n      if (typeof element === 'string') {\n        const lcElement = transformCaseFunc(element);\n\n        if (lcElement !== element) {\n          // Config presets (e.g. tags.js, attrs.js) are immutable.\n          if (!isFrozen(array)) {\n            array[l] = lcElement;\n          }\n\n          element = lcElement;\n        }\n      }\n\n      set[element] = true;\n    }\n\n    return set;\n  }\n  /* Shallow clone an object */\n\n  function clone(object) {\n    const newObject = create(null);\n\n    for (const [property, value] of entries(object)) {\n      newObject[property] = value;\n    }\n\n    return newObject;\n  }\n  /* This method automatically checks if the prop is function\n   * or getter and behaves accordingly. */\n\n  function lookupGetter(object, prop) {\n    while (object !== null) {\n      const desc = getOwnPropertyDescriptor(object, prop);\n\n      if (desc) {\n        if (desc.get) {\n          return unapply(desc.get);\n        }\n\n        if (typeof desc.value === 'function') {\n          return unapply(desc.value);\n        }\n      }\n\n      object = getPrototypeOf(object);\n    }\n\n    function fallbackValue(element) {\n      console.warn('fallback value for', element);\n      return null;\n    }\n\n    return fallbackValue;\n  }\n\n  const html$1 = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']); // SVG\n\n  const svg$1 = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);\n  const svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feDropShadow', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']); // List of SVG elements that are disallowed by default.\n  // We still need to know them so that we can do namespace\n  // checks properly in case one wants to add them to\n  // allow-list.\n\n  const svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);\n  const mathMl$1 = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover', 'mprescripts']); // Similarly to SVG, we want to know all MathML elements,\n  // even those that we disallow by default.\n\n  const mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);\n  const text = freeze(['#text']);\n\n  const html = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'nonce', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', 'slot']);\n  const svg = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'transform-origin', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);\n  const mathMl = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);\n  const xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);\n\n  const MUSTACHE_EXPR = seal(/\\{\\{[\\w\\W]*|[\\w\\W]*\\}\\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode\n\n  const ERB_EXPR = seal(/<%[\\w\\W]*|[\\w\\W]*%>/gm);\n  const TMPLIT_EXPR = seal(/\\${[\\w\\W]*}/gm);\n  const DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]/); // eslint-disable-line no-useless-escape\n\n  const ARIA_ATTR = seal(/^aria-[\\-\\w]+$/); // eslint-disable-line no-useless-escape\n\n  const IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i // eslint-disable-line no-useless-escape\n  );\n  const IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\n  const ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g // eslint-disable-line no-control-regex\n  );\n  const DOCTYPE_NAME = seal(/^html$/i);\n\n  var EXPRESSIONS = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    MUSTACHE_EXPR: MUSTACHE_EXPR,\n    ERB_EXPR: ERB_EXPR,\n    TMPLIT_EXPR: TMPLIT_EXPR,\n    DATA_ATTR: DATA_ATTR,\n    ARIA_ATTR: ARIA_ATTR,\n    IS_ALLOWED_URI: IS_ALLOWED_URI,\n    IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA,\n    ATTR_WHITESPACE: ATTR_WHITESPACE,\n    DOCTYPE_NAME: DOCTYPE_NAME\n  });\n\n  const getGlobal = () => typeof window === 'undefined' ? null : window;\n  /**\n   * Creates a no-op policy for internal use only.\n   * Don't export this function outside this module!\n   * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.\n   * @param {HTMLScriptElement} purifyHostElement The Script element used to load DOMPurify (to determine policy name suffix).\n   * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types\n   * are not supported or creating the policy failed).\n   */\n\n\n  const _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, purifyHostElement) {\n    if (typeof trustedTypes !== 'object' || typeof trustedTypes.createPolicy !== 'function') {\n      return null;\n    } // Allow the callers to control the unique policy name\n    // by adding a data-tt-policy-suffix to the script element with the DOMPurify.\n    // Policy creation with duplicate names throws in Trusted Types.\n\n\n    let suffix = null;\n    const ATTR_NAME = 'data-tt-policy-suffix';\n\n    if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {\n      suffix = purifyHostElement.getAttribute(ATTR_NAME);\n    }\n\n    const policyName = 'dompurify' + (suffix ? '#' + suffix : '');\n\n    try {\n      return trustedTypes.createPolicy(policyName, {\n        createHTML(html) {\n          return html;\n        },\n\n        createScriptURL(scriptUrl) {\n          return scriptUrl;\n        }\n\n      });\n    } catch (_) {\n      // Policy creation failed (most likely another DOMPurify script has\n      // already run). Skip creating the policy, as this will only cause errors\n      // if TT are enforced.\n      console.warn('TrustedTypes policy ' + policyName + ' could not be created.');\n      return null;\n    }\n  };\n\n  function createDOMPurify() {\n    let window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();\n\n    const DOMPurify = root => createDOMPurify(root);\n    /**\n     * Version label, exposed for easier checks\n     * if DOMPurify is up to date or not\n     */\n\n\n    DOMPurify.version = '3.0.3';\n    /**\n     * Array of elements that DOMPurify removed during sanitation.\n     * Empty if nothing was removed.\n     */\n\n    DOMPurify.removed = [];\n\n    if (!window || !window.document || window.document.nodeType !== 9) {\n      // Not running in a browser, provide a factory function\n      // so that you can pass your own Window\n      DOMPurify.isSupported = false;\n      return DOMPurify;\n    }\n\n    const originalDocument = window.document;\n    const currentScript = originalDocument.currentScript;\n    let {\n      document\n    } = window;\n    const {\n      DocumentFragment,\n      HTMLTemplateElement,\n      Node,\n      Element,\n      NodeFilter,\n      NamedNodeMap = window.NamedNodeMap || window.MozNamedAttrMap,\n      HTMLFormElement,\n      DOMParser,\n      trustedTypes\n    } = window;\n    const ElementPrototype = Element.prototype;\n    const cloneNode = lookupGetter(ElementPrototype, 'cloneNode');\n    const getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');\n    const getChildNodes = lookupGetter(ElementPrototype, 'childNodes');\n    const getParentNode = lookupGetter(ElementPrototype, 'parentNode'); // As per issue #47, the web-components registry is inherited by a\n    // new document created via createHTMLDocument. As per the spec\n    // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)\n    // a new empty registry is used when creating a template contents owner\n    // document, so we use that as our parent document to ensure nothing\n    // is inherited.\n\n    if (typeof HTMLTemplateElement === 'function') {\n      const template = document.createElement('template');\n\n      if (template.content && template.content.ownerDocument) {\n        document = template.content.ownerDocument;\n      }\n    }\n\n    let trustedTypesPolicy;\n    let emptyHTML = '';\n    const {\n      implementation,\n      createNodeIterator,\n      createDocumentFragment,\n      getElementsByTagName\n    } = document;\n    const {\n      importNode\n    } = originalDocument;\n    let hooks = {};\n    /**\n     * Expose whether this browser supports running the full DOMPurify.\n     */\n\n    DOMPurify.isSupported = typeof entries === 'function' && typeof getParentNode === 'function' && implementation && implementation.createHTMLDocument !== undefined;\n    const {\n      MUSTACHE_EXPR,\n      ERB_EXPR,\n      TMPLIT_EXPR,\n      DATA_ATTR,\n      ARIA_ATTR,\n      IS_SCRIPT_OR_DATA,\n      ATTR_WHITESPACE\n    } = EXPRESSIONS;\n    let {\n      IS_ALLOWED_URI: IS_ALLOWED_URI$1\n    } = EXPRESSIONS;\n    /**\n     * We consider the elements and attributes below to be safe. Ideally\n     * don't add any new ones but feel free to remove unwanted ones.\n     */\n\n    /* allowed element names */\n\n    let ALLOWED_TAGS = null;\n    const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);\n    /* Allowed attribute names */\n\n    let ALLOWED_ATTR = null;\n    const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html, ...svg, ...mathMl, ...xml]);\n    /*\n     * Configure how DOMPUrify should handle custom elements and their attributes as well as customized built-in elements.\n     * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)\n     * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)\n     * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.\n     */\n\n    let CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {\n      tagNameCheck: {\n        writable: true,\n        configurable: false,\n        enumerable: true,\n        value: null\n      },\n      attributeNameCheck: {\n        writable: true,\n        configurable: false,\n        enumerable: true,\n        value: null\n      },\n      allowCustomizedBuiltInElements: {\n        writable: true,\n        configurable: false,\n        enumerable: true,\n        value: false\n      }\n    }));\n    /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */\n\n    let FORBID_TAGS = null;\n    /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */\n\n    let FORBID_ATTR = null;\n    /* Decide if ARIA attributes are okay */\n\n    let ALLOW_ARIA_ATTR = true;\n    /* Decide if custom data attributes are okay */\n\n    let ALLOW_DATA_ATTR = true;\n    /* Decide if unknown protocols are okay */\n\n    let ALLOW_UNKNOWN_PROTOCOLS = false;\n    /* Decide if self-closing tags in attributes are allowed.\n     * Usually removed due to a mXSS issue in jQuery 3.0 */\n\n    let ALLOW_SELF_CLOSE_IN_ATTR = true;\n    /* Output should be safe for common template engines.\n     * This means, DOMPurify removes data attributes, mustaches and ERB\n     */\n\n    let SAFE_FOR_TEMPLATES = false;\n    /* Decide if document with <html>... should be returned */\n\n    let WHOLE_DOCUMENT = false;\n    /* Track whether config is already set on this instance of DOMPurify. */\n\n    let SET_CONFIG = false;\n    /* Decide if all elements (e.g. style, script) must be children of\n     * document.body. By default, browsers might move them to document.head */\n\n    let FORCE_BODY = false;\n    /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html\n     * string (or a TrustedHTML object if Trusted Types are supported).\n     * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead\n     */\n\n    let RETURN_DOM = false;\n    /* Decide if a DOM `DocumentFragment` should be returned, instead of a html\n     * string  (or a TrustedHTML object if Trusted Types are supported) */\n\n    let RETURN_DOM_FRAGMENT = false;\n    /* Try to return a Trusted Type object instead of a string, return a string in\n     * case Trusted Types are not supported  */\n\n    let RETURN_TRUSTED_TYPE = false;\n    /* Output should be free from DOM clobbering attacks?\n     * This sanitizes markups named with colliding, clobberable built-in DOM APIs.\n     */\n\n    let SANITIZE_DOM = true;\n    /* Achieve full DOM Clobbering protection by isolating the namespace of named\n     * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.\n     *\n     * HTML/DOM spec rules that enable DOM Clobbering:\n     *   - Named Access on Window (§7.3.3)\n     *   - DOM Tree Accessors (§3.1.5)\n     *   - Form Element Parent-Child Relations (§4.10.3)\n     *   - Iframe srcdoc / Nested WindowProxies (§4.8.5)\n     *   - HTMLCollection (§4.2.10.2)\n     *\n     * Namespace isolation is implemented by prefixing `id` and `name` attributes\n     * with a constant string, i.e., `user-content-`\n     */\n\n    let SANITIZE_NAMED_PROPS = false;\n    const SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';\n    /* Keep element content when removing element? */\n\n    let KEEP_CONTENT = true;\n    /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead\n     * of importing it into a new Document and returning a sanitized copy */\n\n    let IN_PLACE = false;\n    /* Allow usage of profiles like html, svg and mathMl */\n\n    let USE_PROFILES = {};\n    /* Tags to ignore content of when KEEP_CONTENT is true */\n\n    let FORBID_CONTENTS = null;\n    const DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);\n    /* Tags that are safe for data: URIs */\n\n    let DATA_URI_TAGS = null;\n    const DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);\n    /* Attributes safe for values like \"javascript:\" */\n\n    let URI_SAFE_ATTRIBUTES = null;\n    const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);\n    const MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n    const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n    const HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\n    /* Document namespace */\n\n    let NAMESPACE = HTML_NAMESPACE;\n    let IS_EMPTY_INPUT = false;\n    /* Allowed XHTML+XML namespaces */\n\n    let ALLOWED_NAMESPACES = null;\n    const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);\n    /* Parsing of strict XHTML documents */\n\n    let PARSER_MEDIA_TYPE;\n    const SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];\n    const DEFAULT_PARSER_MEDIA_TYPE = 'text/html';\n    let transformCaseFunc;\n    /* Keep a reference to config to pass to hooks */\n\n    let CONFIG = null;\n    /* Ideally, do not touch anything below this line */\n\n    /* ______________________________________________ */\n\n    const formElement = document.createElement('form');\n\n    const isRegexOrFunction = function isRegexOrFunction(testValue) {\n      return testValue instanceof RegExp || testValue instanceof Function;\n    };\n    /**\n     * _parseConfig\n     *\n     * @param  {Object} cfg optional config literal\n     */\n    // eslint-disable-next-line complexity\n\n\n    const _parseConfig = function _parseConfig(cfg) {\n      if (CONFIG && CONFIG === cfg) {\n        return;\n      }\n      /* Shield configuration object from tampering */\n\n\n      if (!cfg || typeof cfg !== 'object') {\n        cfg = {};\n      }\n      /* Shield configuration object from prototype pollution */\n\n\n      cfg = clone(cfg);\n      PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes\n      SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE; // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.\n\n      transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? stringToString : stringToLowerCase;\n      /* Set configuration parameters */\n\n      ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;\n      ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;\n      ALLOWED_NAMESPACES = 'ALLOWED_NAMESPACES' in cfg ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;\n      URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), // eslint-disable-line indent\n      cfg.ADD_URI_SAFE_ATTR, // eslint-disable-line indent\n      transformCaseFunc // eslint-disable-line indent\n      ) // eslint-disable-line indent\n      : DEFAULT_URI_SAFE_ATTRIBUTES;\n      DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), // eslint-disable-line indent\n      cfg.ADD_DATA_URI_TAGS, // eslint-disable-line indent\n      transformCaseFunc // eslint-disable-line indent\n      ) // eslint-disable-line indent\n      : DEFAULT_DATA_URI_TAGS;\n      FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;\n      FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};\n      FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};\n      USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;\n      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true\n\n      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true\n\n      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false\n\n      ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false; // Default true\n\n      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false\n\n      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false\n\n      RETURN_DOM = cfg.RETURN_DOM || false; // Default false\n\n      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false\n\n      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false\n\n      FORCE_BODY = cfg.FORCE_BODY || false; // Default false\n\n      SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true\n\n      SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false\n\n      KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true\n\n      IN_PLACE = cfg.IN_PLACE || false; // Default false\n\n      IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;\n      NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;\n      CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};\n\n      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {\n        CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;\n      }\n\n      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {\n        CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;\n      }\n\n      if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {\n        CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;\n      }\n\n      if (SAFE_FOR_TEMPLATES) {\n        ALLOW_DATA_ATTR = false;\n      }\n\n      if (RETURN_DOM_FRAGMENT) {\n        RETURN_DOM = true;\n      }\n      /* Parse profile info */\n\n\n      if (USE_PROFILES) {\n        ALLOWED_TAGS = addToSet({}, [...text]);\n        ALLOWED_ATTR = [];\n\n        if (USE_PROFILES.html === true) {\n          addToSet(ALLOWED_TAGS, html$1);\n          addToSet(ALLOWED_ATTR, html);\n        }\n\n        if (USE_PROFILES.svg === true) {\n          addToSet(ALLOWED_TAGS, svg$1);\n          addToSet(ALLOWED_ATTR, svg);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n\n        if (USE_PROFILES.svgFilters === true) {\n          addToSet(ALLOWED_TAGS, svgFilters);\n          addToSet(ALLOWED_ATTR, svg);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n\n        if (USE_PROFILES.mathMl === true) {\n          addToSet(ALLOWED_TAGS, mathMl$1);\n          addToSet(ALLOWED_ATTR, mathMl);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n      }\n      /* Merge configuration parameters */\n\n\n      if (cfg.ADD_TAGS) {\n        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n          ALLOWED_TAGS = clone(ALLOWED_TAGS);\n        }\n\n        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);\n      }\n\n      if (cfg.ADD_ATTR) {\n        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n          ALLOWED_ATTR = clone(ALLOWED_ATTR);\n        }\n\n        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);\n      }\n\n      if (cfg.ADD_URI_SAFE_ATTR) {\n        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);\n      }\n\n      if (cfg.FORBID_CONTENTS) {\n        if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {\n          FORBID_CONTENTS = clone(FORBID_CONTENTS);\n        }\n\n        addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);\n      }\n      /* Add #text in case KEEP_CONTENT is set to true */\n\n\n      if (KEEP_CONTENT) {\n        ALLOWED_TAGS['#text'] = true;\n      }\n      /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */\n\n\n      if (WHOLE_DOCUMENT) {\n        addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);\n      }\n      /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */\n\n\n      if (ALLOWED_TAGS.table) {\n        addToSet(ALLOWED_TAGS, ['tbody']);\n        delete FORBID_TAGS.tbody;\n      }\n\n      if (cfg.TRUSTED_TYPES_POLICY) {\n        if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== 'function') {\n          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createHTML\" hook.');\n        }\n\n        if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== 'function') {\n          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createScriptURL\" hook.');\n        } // Overwrite existing TrustedTypes policy.\n\n\n        trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY; // Sign local variables required by `sanitize`.\n\n        emptyHTML = trustedTypesPolicy.createHTML('');\n      } else {\n        // Uninitialized policy, attempt to initialize the internal dompurify policy.\n        if (trustedTypesPolicy === undefined) {\n          trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);\n        } // If creating the internal policy succeeded sign internal variables.\n\n\n        if (trustedTypesPolicy !== null && typeof emptyHTML === 'string') {\n          emptyHTML = trustedTypesPolicy.createHTML('');\n        }\n      } // Prevent further manipulation of configuration.\n      // Not available in IE8, Safari 5, etc.\n\n\n      if (freeze) {\n        freeze(cfg);\n      }\n\n      CONFIG = cfg;\n    };\n\n    const MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);\n    const HTML_INTEGRATION_POINTS = addToSet({}, ['foreignobject', 'desc', 'title', 'annotation-xml']); // Certain elements are allowed in both SVG and HTML\n    // namespace. We need to specify them explicitly\n    // so that they don't get erroneously deleted from\n    // HTML namespace.\n\n    const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ['title', 'style', 'font', 'a', 'script']);\n    /* Keep track of all possible SVG and MathML tags\n     * so that we can perform the namespace checks\n     * correctly. */\n\n    const ALL_SVG_TAGS = addToSet({}, svg$1);\n    addToSet(ALL_SVG_TAGS, svgFilters);\n    addToSet(ALL_SVG_TAGS, svgDisallowed);\n    const ALL_MATHML_TAGS = addToSet({}, mathMl$1);\n    addToSet(ALL_MATHML_TAGS, mathMlDisallowed);\n    /**\n     *\n     *\n     * @param  {Element} element a DOM element whose namespace is being checked\n     * @returns {boolean} Return false if the element has a\n     *  namespace that a spec-compliant parser would never\n     *  return. Return true otherwise.\n     */\n\n    const _checkValidNamespace = function _checkValidNamespace(element) {\n      let parent = getParentNode(element); // In JSDOM, if we're inside shadow DOM, then parentNode\n      // can be null. We just simulate parent in this case.\n\n      if (!parent || !parent.tagName) {\n        parent = {\n          namespaceURI: NAMESPACE,\n          tagName: 'template'\n        };\n      }\n\n      const tagName = stringToLowerCase(element.tagName);\n      const parentTagName = stringToLowerCase(parent.tagName);\n\n      if (!ALLOWED_NAMESPACES[element.namespaceURI]) {\n        return false;\n      }\n\n      if (element.namespaceURI === SVG_NAMESPACE) {\n        // The only way to switch from HTML namespace to SVG\n        // is via <svg>. If it happens via any other tag, then\n        // it should be killed.\n        if (parent.namespaceURI === HTML_NAMESPACE) {\n          return tagName === 'svg';\n        } // The only way to switch from MathML to SVG is via`\n        // svg if parent is either <annotation-xml> or MathML\n        // text integration points.\n\n\n        if (parent.namespaceURI === MATHML_NAMESPACE) {\n          return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);\n        } // We only allow elements that are defined in SVG\n        // spec. All others are disallowed in SVG namespace.\n\n\n        return Boolean(ALL_SVG_TAGS[tagName]);\n      }\n\n      if (element.namespaceURI === MATHML_NAMESPACE) {\n        // The only way to switch from HTML namespace to MathML\n        // is via <math>. If it happens via any other tag, then\n        // it should be killed.\n        if (parent.namespaceURI === HTML_NAMESPACE) {\n          return tagName === 'math';\n        } // The only way to switch from SVG to MathML is via\n        // <math> and HTML integration points\n\n\n        if (parent.namespaceURI === SVG_NAMESPACE) {\n          return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];\n        } // We only allow elements that are defined in MathML\n        // spec. All others are disallowed in MathML namespace.\n\n\n        return Boolean(ALL_MATHML_TAGS[tagName]);\n      }\n\n      if (element.namespaceURI === HTML_NAMESPACE) {\n        // The only way to switch from SVG to HTML is via\n        // HTML integration points, and from MathML to HTML\n        // is via MathML text integration points\n        if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {\n          return false;\n        }\n\n        if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {\n          return false;\n        } // We disallow tags that are specific for MathML\n        // or SVG and should never appear in HTML namespace\n\n\n        return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);\n      } // For XHTML and XML documents that support custom namespaces\n\n\n      if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && ALLOWED_NAMESPACES[element.namespaceURI]) {\n        return true;\n      } // The code should never reach this place (this means\n      // that the element somehow got namespace that is not\n      // HTML, SVG, MathML or allowed via ALLOWED_NAMESPACES).\n      // Return false just in case.\n\n\n      return false;\n    };\n    /**\n     * _forceRemove\n     *\n     * @param  {Node} node a DOM node\n     */\n\n\n    const _forceRemove = function _forceRemove(node) {\n      arrayPush(DOMPurify.removed, {\n        element: node\n      });\n\n      try {\n        // eslint-disable-next-line unicorn/prefer-dom-node-remove\n        node.parentNode.removeChild(node);\n      } catch (_) {\n        node.remove();\n      }\n    };\n    /**\n     * _removeAttribute\n     *\n     * @param  {String} name an Attribute name\n     * @param  {Node} node a DOM node\n     */\n\n\n    const _removeAttribute = function _removeAttribute(name, node) {\n      try {\n        arrayPush(DOMPurify.removed, {\n          attribute: node.getAttributeNode(name),\n          from: node\n        });\n      } catch (_) {\n        arrayPush(DOMPurify.removed, {\n          attribute: null,\n          from: node\n        });\n      }\n\n      node.removeAttribute(name); // We void attribute values for unremovable \"is\"\" attributes\n\n      if (name === 'is' && !ALLOWED_ATTR[name]) {\n        if (RETURN_DOM || RETURN_DOM_FRAGMENT) {\n          try {\n            _forceRemove(node);\n          } catch (_) {}\n        } else {\n          try {\n            node.setAttribute(name, '');\n          } catch (_) {}\n        }\n      }\n    };\n    /**\n     * _initDocument\n     *\n     * @param  {String} dirty a string of dirty markup\n     * @return {Document} a DOM, filled with the dirty markup\n     */\n\n\n    const _initDocument = function _initDocument(dirty) {\n      /* Create a HTML document */\n      let doc;\n      let leadingWhitespace;\n\n      if (FORCE_BODY) {\n        dirty = '<remove></remove>' + dirty;\n      } else {\n        /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */\n        const matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\n        leadingWhitespace = matches && matches[0];\n      }\n\n      if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && NAMESPACE === HTML_NAMESPACE) {\n        // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)\n        dirty = '<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>' + dirty + '</body></html>';\n      }\n\n      const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n      /*\n       * Use the DOMParser API by default, fallback later if needs be\n       * DOMParser not work for svg when has multiple root element.\n       */\n\n      if (NAMESPACE === HTML_NAMESPACE) {\n        try {\n          doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);\n        } catch (_) {}\n      }\n      /* Use createHTMLDocument in case DOMParser is not available */\n\n\n      if (!doc || !doc.documentElement) {\n        doc = implementation.createDocument(NAMESPACE, 'template', null);\n\n        try {\n          doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;\n        } catch (_) {// Syntax error if dirtyPayload is invalid xml\n        }\n      }\n\n      const body = doc.body || doc.documentElement;\n\n      if (dirty && leadingWhitespace) {\n        body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);\n      }\n      /* Work on whole document or just its body */\n\n\n      if (NAMESPACE === HTML_NAMESPACE) {\n        return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];\n      }\n\n      return WHOLE_DOCUMENT ? doc.documentElement : body;\n    };\n    /**\n     * _createIterator\n     *\n     * @param  {Document} root document/fragment to create iterator for\n     * @return {Iterator} iterator instance\n     */\n\n\n    const _createIterator = function _createIterator(root) {\n      return createNodeIterator.call(root.ownerDocument || root, root, // eslint-disable-next-line no-bitwise\n      NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);\n    };\n    /**\n     * _isClobbered\n     *\n     * @param  {Node} elm element to check for clobbering attacks\n     * @return {Boolean} true if clobbered, false if safe\n     */\n\n\n    const _isClobbered = function _isClobbered(elm) {\n      return elm instanceof HTMLFormElement && (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function' || typeof elm.hasChildNodes !== 'function');\n    };\n    /**\n     * _isNode\n     *\n     * @param  {Node} obj object to check whether it's a DOM node\n     * @return {Boolean} true is object is a DOM node\n     */\n\n\n    const _isNode = function _isNode(object) {\n      return typeof Node === 'object' ? object instanceof Node : object && typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';\n    };\n    /**\n     * _executeHook\n     * Execute user configurable hooks\n     *\n     * @param  {String} entryPoint  Name of the hook's entry point\n     * @param  {Node} currentNode node to work on with the hook\n     * @param  {Object} data additional hook parameters\n     */\n\n\n    const _executeHook = function _executeHook(entryPoint, currentNode, data) {\n      if (!hooks[entryPoint]) {\n        return;\n      }\n\n      arrayForEach(hooks[entryPoint], hook => {\n        hook.call(DOMPurify, currentNode, data, CONFIG);\n      });\n    };\n    /**\n     * _sanitizeElements\n     *\n     * @protect nodeName\n     * @protect textContent\n     * @protect removeChild\n     *\n     * @param   {Node} currentNode to check for permission to exist\n     * @return  {Boolean} true if node was killed, false if left alive\n     */\n\n\n    const _sanitizeElements = function _sanitizeElements(currentNode) {\n      let content;\n      /* Execute a hook if present */\n\n      _executeHook('beforeSanitizeElements', currentNode, null);\n      /* Check if element is clobbered or can clobber */\n\n\n      if (_isClobbered(currentNode)) {\n        _forceRemove(currentNode);\n\n        return true;\n      }\n      /* Now let's check the element's type and name */\n\n\n      const tagName = transformCaseFunc(currentNode.nodeName);\n      /* Execute a hook if present */\n\n      _executeHook('uponSanitizeElement', currentNode, {\n        tagName,\n        allowedTags: ALLOWED_TAGS\n      });\n      /* Detect mXSS attempts abusing namespace confusion */\n\n\n      if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\\w]/g, currentNode.innerHTML) && regExpTest(/<[/\\w]/g, currentNode.textContent)) {\n        _forceRemove(currentNode);\n\n        return true;\n      }\n      /* Remove element if anything forbids its presence */\n\n\n      if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n        /* Check if we have a custom element to handle */\n        if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {\n          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) return false;\n          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) return false;\n        }\n        /* Keep content except for bad-listed elements */\n\n\n        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {\n          const parentNode = getParentNode(currentNode) || currentNode.parentNode;\n          const childNodes = getChildNodes(currentNode) || currentNode.childNodes;\n\n          if (childNodes && parentNode) {\n            const childCount = childNodes.length;\n\n            for (let i = childCount - 1; i >= 0; --i) {\n              parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));\n            }\n          }\n        }\n\n        _forceRemove(currentNode);\n\n        return true;\n      }\n      /* Check whether element has a valid namespace */\n\n\n      if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {\n        _forceRemove(currentNode);\n\n        return true;\n      }\n      /* Make sure that older browsers don't get noscript mXSS */\n\n\n      if ((tagName === 'noscript' || tagName === 'noembed') && regExpTest(/<\\/no(script|embed)/i, currentNode.innerHTML)) {\n        _forceRemove(currentNode);\n\n        return true;\n      }\n      /* Sanitize element content to be template-safe */\n\n\n      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {\n        /* Get the element's text content */\n        content = currentNode.textContent;\n        content = stringReplace(content, MUSTACHE_EXPR, ' ');\n        content = stringReplace(content, ERB_EXPR, ' ');\n        content = stringReplace(content, TMPLIT_EXPR, ' ');\n\n        if (currentNode.textContent !== content) {\n          arrayPush(DOMPurify.removed, {\n            element: currentNode.cloneNode()\n          });\n          currentNode.textContent = content;\n        }\n      }\n      /* Execute a hook if present */\n\n\n      _executeHook('afterSanitizeElements', currentNode, null);\n\n      return false;\n    };\n    /**\n     * _isValidAttribute\n     *\n     * @param  {string} lcTag Lowercase tag name of containing element.\n     * @param  {string} lcName Lowercase attribute name.\n     * @param  {string} value Attribute value.\n     * @return {Boolean} Returns true if `value` is valid, otherwise false.\n     */\n    // eslint-disable-next-line complexity\n\n\n    const _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {\n      /* Make sure attribute cannot clobber */\n      if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {\n        return false;\n      }\n      /* Allow valid data-* attributes: At least one character after \"-\"\n          (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)\n          XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)\n          We don't need to check the value; it's always URI safe. */\n\n\n      if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n        if ( // First condition does a very basic check if a) it's basically a valid custom element tagname AND\n        // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck\n        // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck\n        _basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || // Alternative, second condition checks if it's an `is`-attribute, AND\n        // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck\n        lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ; else {\n          return false;\n        }\n        /* Check value is safe. First, is attr inert? If so, is safe */\n\n      } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA, stringReplace(value, ATTR_WHITESPACE, ''))) ; else if (value) {\n        return false;\n      } else ;\n\n      return true;\n    };\n    /**\n     * _basicCustomElementCheck\n     * checks if at least one dash is included in tagName, and it's not the first char\n     * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name\n     * @param {string} tagName name of the tag of the node to sanitize\n     */\n\n\n    const _basicCustomElementTest = function _basicCustomElementTest(tagName) {\n      return tagName.indexOf('-') > 0;\n    };\n    /**\n     * _sanitizeAttributes\n     *\n     * @protect attributes\n     * @protect nodeName\n     * @protect removeAttribute\n     * @protect setAttribute\n     *\n     * @param  {Node} currentNode to sanitize\n     */\n\n\n    const _sanitizeAttributes = function _sanitizeAttributes(currentNode) {\n      let attr;\n      let value;\n      let lcName;\n      let l;\n      /* Execute a hook if present */\n\n      _executeHook('beforeSanitizeAttributes', currentNode, null);\n\n      const {\n        attributes\n      } = currentNode;\n      /* Check if we have attributes; if not we might have a text node */\n\n      if (!attributes) {\n        return;\n      }\n\n      const hookEvent = {\n        attrName: '',\n        attrValue: '',\n        keepAttr: true,\n        allowedAttributes: ALLOWED_ATTR\n      };\n      l = attributes.length;\n      /* Go backwards over all attributes; safely remove bad ones */\n\n      while (l--) {\n        attr = attributes[l];\n        const {\n          name,\n          namespaceURI\n        } = attr;\n        value = name === 'value' ? attr.value : stringTrim(attr.value);\n        lcName = transformCaseFunc(name);\n        /* Execute a hook if present */\n\n        hookEvent.attrName = lcName;\n        hookEvent.attrValue = value;\n        hookEvent.keepAttr = true;\n        hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set\n\n        _executeHook('uponSanitizeAttribute', currentNode, hookEvent);\n\n        value = hookEvent.attrValue;\n        /* Did the hooks approve of the attribute? */\n\n        if (hookEvent.forceKeepAttr) {\n          continue;\n        }\n        /* Remove attribute */\n\n\n        _removeAttribute(name, currentNode);\n        /* Did the hooks approve of the attribute? */\n\n\n        if (!hookEvent.keepAttr) {\n          continue;\n        }\n        /* Work around a security issue in jQuery 3.0 */\n\n\n        if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\\/>/i, value)) {\n          _removeAttribute(name, currentNode);\n\n          continue;\n        }\n        /* Sanitize attribute content to be template-safe */\n\n\n        if (SAFE_FOR_TEMPLATES) {\n          value = stringReplace(value, MUSTACHE_EXPR, ' ');\n          value = stringReplace(value, ERB_EXPR, ' ');\n          value = stringReplace(value, TMPLIT_EXPR, ' ');\n        }\n        /* Is `value` valid for this attribute? */\n\n\n        const lcTag = transformCaseFunc(currentNode.nodeName);\n\n        if (!_isValidAttribute(lcTag, lcName, value)) {\n          continue;\n        }\n        /* Full DOM Clobbering protection via namespace isolation,\n         * Prefix id and name attributes with `user-content-`\n         */\n\n\n        if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {\n          // Remove the attribute with this value\n          _removeAttribute(name, currentNode); // Prefix the value and later re-create the attribute with the sanitized value\n\n\n          value = SANITIZE_NAMED_PROPS_PREFIX + value;\n        }\n        /* Handle attributes that require Trusted Types */\n\n\n        if (trustedTypesPolicy && typeof trustedTypes === 'object' && typeof trustedTypes.getAttributeType === 'function') {\n          if (namespaceURI) ; else {\n            switch (trustedTypes.getAttributeType(lcTag, lcName)) {\n              case 'TrustedHTML':\n                {\n                  value = trustedTypesPolicy.createHTML(value);\n                  break;\n                }\n\n              case 'TrustedScriptURL':\n                {\n                  value = trustedTypesPolicy.createScriptURL(value);\n                  break;\n                }\n            }\n          }\n        }\n        /* Handle invalid data-* attribute set by try-catching it */\n\n\n        try {\n          if (namespaceURI) {\n            currentNode.setAttributeNS(namespaceURI, name, value);\n          } else {\n            /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. \"x-schema\". */\n            currentNode.setAttribute(name, value);\n          }\n\n          arrayPop(DOMPurify.removed);\n        } catch (_) {}\n      }\n      /* Execute a hook if present */\n\n\n      _executeHook('afterSanitizeAttributes', currentNode, null);\n    };\n    /**\n     * _sanitizeShadowDOM\n     *\n     * @param  {DocumentFragment} fragment to iterate over recursively\n     */\n\n\n    const _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {\n      let shadowNode;\n\n      const shadowIterator = _createIterator(fragment);\n      /* Execute a hook if present */\n\n\n      _executeHook('beforeSanitizeShadowDOM', fragment, null);\n\n      while (shadowNode = shadowIterator.nextNode()) {\n        /* Execute a hook if present */\n        _executeHook('uponSanitizeShadowNode', shadowNode, null);\n        /* Sanitize tags and elements */\n\n\n        if (_sanitizeElements(shadowNode)) {\n          continue;\n        }\n        /* Deep shadow DOM detected */\n\n\n        if (shadowNode.content instanceof DocumentFragment) {\n          _sanitizeShadowDOM(shadowNode.content);\n        }\n        /* Check attributes, sanitize if necessary */\n\n\n        _sanitizeAttributes(shadowNode);\n      }\n      /* Execute a hook if present */\n\n\n      _executeHook('afterSanitizeShadowDOM', fragment, null);\n    };\n    /**\n     * Sanitize\n     * Public method providing core sanitation functionality\n     *\n     * @param {String|Node} dirty string or DOM node\n     * @param {Object} configuration object\n     */\n    // eslint-disable-next-line complexity\n\n\n    DOMPurify.sanitize = function (dirty) {\n      let cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      let body;\n      let importedNode;\n      let currentNode;\n      let returnNode;\n      /* Make sure we have a string to sanitize.\n        DO NOT return early, as this will return the wrong type if\n        the user has requested a DOM object rather than a string */\n\n      IS_EMPTY_INPUT = !dirty;\n\n      if (IS_EMPTY_INPUT) {\n        dirty = '<!-->';\n      }\n      /* Stringify, in case dirty is an object */\n\n\n      if (typeof dirty !== 'string' && !_isNode(dirty)) {\n        if (typeof dirty.toString === 'function') {\n          dirty = dirty.toString();\n\n          if (typeof dirty !== 'string') {\n            throw typeErrorCreate('dirty is not a string, aborting');\n          }\n        } else {\n          throw typeErrorCreate('toString is not a function');\n        }\n      }\n      /* Return dirty HTML if DOMPurify cannot run */\n\n\n      if (!DOMPurify.isSupported) {\n        return dirty;\n      }\n      /* Assign config vars */\n\n\n      if (!SET_CONFIG) {\n        _parseConfig(cfg);\n      }\n      /* Clean up removed elements */\n\n\n      DOMPurify.removed = [];\n      /* Check if dirty is correctly typed for IN_PLACE */\n\n      if (typeof dirty === 'string') {\n        IN_PLACE = false;\n      }\n\n      if (IN_PLACE) {\n        /* Do some early pre-sanitization to avoid unsafe root nodes */\n        if (dirty.nodeName) {\n          const tagName = transformCaseFunc(dirty.nodeName);\n\n          if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n            throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');\n          }\n        }\n      } else if (dirty instanceof Node) {\n        /* If dirty is a DOM element, append to an empty document to avoid\n           elements being stripped by the parser */\n        body = _initDocument('<!---->');\n        importedNode = body.ownerDocument.importNode(dirty, true);\n\n        if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {\n          /* Node is already a body, use as is */\n          body = importedNode;\n        } else if (importedNode.nodeName === 'HTML') {\n          body = importedNode;\n        } else {\n          // eslint-disable-next-line unicorn/prefer-dom-node-append\n          body.appendChild(importedNode);\n        }\n      } else {\n        /* Exit directly if we have nothing to do */\n        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes\n        dirty.indexOf('<') === -1) {\n          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;\n        }\n        /* Initialize the document to work on */\n\n\n        body = _initDocument(dirty);\n        /* Check we have a DOM node from the data */\n\n        if (!body) {\n          return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';\n        }\n      }\n      /* Remove first element node (ours) if FORCE_BODY is set */\n\n\n      if (body && FORCE_BODY) {\n        _forceRemove(body.firstChild);\n      }\n      /* Get node iterator */\n\n\n      const nodeIterator = _createIterator(IN_PLACE ? dirty : body);\n      /* Now start iterating over the created document */\n\n\n      while (currentNode = nodeIterator.nextNode()) {\n        /* Sanitize tags and elements */\n        if (_sanitizeElements(currentNode)) {\n          continue;\n        }\n        /* Shadow DOM detected, sanitize it */\n\n\n        if (currentNode.content instanceof DocumentFragment) {\n          _sanitizeShadowDOM(currentNode.content);\n        }\n        /* Check attributes, sanitize if necessary */\n\n\n        _sanitizeAttributes(currentNode);\n      }\n      /* If we sanitized `dirty` in-place, return it. */\n\n\n      if (IN_PLACE) {\n        return dirty;\n      }\n      /* Return sanitized string or DOM */\n\n\n      if (RETURN_DOM) {\n        if (RETURN_DOM_FRAGMENT) {\n          returnNode = createDocumentFragment.call(body.ownerDocument);\n\n          while (body.firstChild) {\n            // eslint-disable-next-line unicorn/prefer-dom-node-append\n            returnNode.appendChild(body.firstChild);\n          }\n        } else {\n          returnNode = body;\n        }\n\n        if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmod) {\n          /*\n            AdoptNode() is not used because internal state is not reset\n            (e.g. the past names map of a HTMLFormElement), this is safe\n            in theory but we would rather not risk another attack vector.\n            The state that is cloned by importNode() is explicitly defined\n            by the specs.\n          */\n          returnNode = importNode.call(originalDocument, returnNode, true);\n        }\n\n        return returnNode;\n      }\n\n      let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n      /* Serialize doctype if allowed */\n\n      if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {\n        serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\\n' + serializedHTML;\n      }\n      /* Sanitize final string template-safe */\n\n\n      if (SAFE_FOR_TEMPLATES) {\n        serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR, ' ');\n        serializedHTML = stringReplace(serializedHTML, ERB_EXPR, ' ');\n        serializedHTML = stringReplace(serializedHTML, TMPLIT_EXPR, ' ');\n      }\n\n      return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\n    };\n    /**\n     * Public method to set the configuration once\n     * setConfig\n     *\n     * @param {Object} cfg configuration object\n     */\n\n\n    DOMPurify.setConfig = function (cfg) {\n      _parseConfig(cfg);\n\n      SET_CONFIG = true;\n    };\n    /**\n     * Public method to remove the configuration\n     * clearConfig\n     *\n     */\n\n\n    DOMPurify.clearConfig = function () {\n      CONFIG = null;\n      SET_CONFIG = false;\n    };\n    /**\n     * Public method to check if an attribute value is valid.\n     * Uses last set config, if any. Otherwise, uses config defaults.\n     * isValidAttribute\n     *\n     * @param  {string} tag Tag name of containing element.\n     * @param  {string} attr Attribute name.\n     * @param  {string} value Attribute value.\n     * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.\n     */\n\n\n    DOMPurify.isValidAttribute = function (tag, attr, value) {\n      /* Initialize shared config vars if necessary. */\n      if (!CONFIG) {\n        _parseConfig({});\n      }\n\n      const lcTag = transformCaseFunc(tag);\n      const lcName = transformCaseFunc(attr);\n      return _isValidAttribute(lcTag, lcName, value);\n    };\n    /**\n     * AddHook\n     * Public method to add DOMPurify hooks\n     *\n     * @param {String} entryPoint entry point for the hook to add\n     * @param {Function} hookFunction function to execute\n     */\n\n\n    DOMPurify.addHook = function (entryPoint, hookFunction) {\n      if (typeof hookFunction !== 'function') {\n        return;\n      }\n\n      hooks[entryPoint] = hooks[entryPoint] || [];\n      arrayPush(hooks[entryPoint], hookFunction);\n    };\n    /**\n     * RemoveHook\n     * Public method to remove a DOMPurify hook at a given entryPoint\n     * (pops it from the stack of hooks if more are present)\n     *\n     * @param {String} entryPoint entry point for the hook to remove\n     * @return {Function} removed(popped) hook\n     */\n\n\n    DOMPurify.removeHook = function (entryPoint) {\n      if (hooks[entryPoint]) {\n        return arrayPop(hooks[entryPoint]);\n      }\n    };\n    /**\n     * RemoveHooks\n     * Public method to remove all DOMPurify hooks at a given entryPoint\n     *\n     * @param  {String} entryPoint entry point for the hooks to remove\n     */\n\n\n    DOMPurify.removeHooks = function (entryPoint) {\n      if (hooks[entryPoint]) {\n        hooks[entryPoint] = [];\n      }\n    };\n    /**\n     * RemoveAllHooks\n     * Public method to remove all DOMPurify hooks\n     *\n     */\n\n\n    DOMPurify.removeAllHooks = function () {\n      hooks = {};\n    };\n\n    return DOMPurify;\n  }\n\n  var purify = createDOMPurify();\n\n  return purify;\n\n}));\n//# sourceMappingURL=purify.js.map\n\n\n//# sourceURL=webpack://@formio/core/./node_modules/dompurify/dist/purify.js?");

/***/ }),

/***/ "./src/utils/Evaluator.ts":
/*!********************************!*\
  !*** ./src/utils/Evaluator.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Evaluator = exports.BaseEvaluator = void 0;\nconst _ = __importStar(__webpack_require__(/*! @formio/lodash */ \"./node_modules/@formio/lodash/lib/index.js\"));\n// BaseEvaluator is for extending.\nclass BaseEvaluator {\n    static evaluator(func, ...params) {\n        if (Evaluator.noeval) {\n            console.warn('No evaluations allowed for this renderer.');\n            return _.noop;\n        }\n        if (typeof func === 'function') {\n            return func;\n        }\n        if (typeof params[0] === 'object') {\n            params = _.keys(params[0]);\n        }\n        return new Function(...params, func);\n    }\n    ;\n    static interpolateString(rawTemplate, data, options = {}) {\n        return rawTemplate.replace(/({{\\s*(.*?)\\s*}})/g, (match, $1, $2) => {\n            // If this is a function call and we allow evals.\n            if ($2.indexOf('(') !== -1) {\n                return $2.replace(/([^\\(]+)\\(([^\\)]+)\\s*\\);?/, (evalMatch, funcName, args) => {\n                    funcName = _.trim(funcName);\n                    const func = _.get(data, funcName);\n                    if (func) {\n                        if (args) {\n                            args = args.split(',').map((arg) => {\n                                arg = _.trim(arg);\n                                if ((arg.indexOf('\"') === 0) || (arg.indexOf(\"'\") === 0)) {\n                                    return arg.substring(1, arg.length - 1);\n                                }\n                                return _.get(data, arg);\n                            });\n                        }\n                        return Evaluator.evaluate(func, args, '', false, data, options);\n                    }\n                    return '';\n                });\n            }\n            else {\n                let dataPath = $2;\n                if ($2.indexOf('?') !== -1) {\n                    dataPath = $2.replace(/\\?\\./g, '.');\n                }\n                // Allow for conditional values.\n                const parts = dataPath.split('||').map((item) => item.trim());\n                let value = '';\n                let path = '';\n                for (let i = 0; i < parts.length; i++) {\n                    path = parts[i];\n                    value = _.get(data, path);\n                    if (value) {\n                        break;\n                    }\n                }\n                if (options.data) {\n                    _.set(options.data, path, value);\n                }\n                return value;\n            }\n        });\n    }\n    static interpolate(rawTemplate, data, options = {}) {\n        if (typeof rawTemplate === 'function') {\n            try {\n                return rawTemplate(data);\n            }\n            catch (err) {\n                console.warn('Error interpolating template', err, data);\n                return err.message;\n            }\n        }\n        return Evaluator.interpolateString(String(rawTemplate), data, options);\n    }\n    ;\n    /**\n     * Evaluate a method.\n     *\n     * @param func\n     * @param args\n     * @return {*}\n     */\n    static evaluate(func, args = {}, ret = '', interpolate = false, context = {}, options = {}) {\n        let returnVal = null;\n        options = _.isObject(options) ? options : { noeval: options };\n        const component = args.component ? args.component : { key: 'unknown' };\n        if (!args.form && args.instance) {\n            args.form = _.get(args.instance, 'root._form', {});\n        }\n        const componentKey = component.key;\n        if (typeof func === 'string') {\n            if (ret) {\n                func += `;return ${ret}`;\n            }\n            if (interpolate) {\n                func = BaseEvaluator.interpolate(func, args, options);\n            }\n            try {\n                if (Evaluator.noeval || options.noeval) {\n                    func = _.noop;\n                }\n                else {\n                    func = Evaluator.evaluator(func, args, context);\n                }\n                args = _.values(args);\n            }\n            catch (err) {\n                console.warn(`An error occured within the custom function for ${componentKey}`, err);\n                returnVal = null;\n                func = false;\n            }\n        }\n        if (typeof func === 'function') {\n            try {\n                returnVal = Evaluator.execute(func, args, context, options);\n            }\n            catch (err) {\n                returnVal = null;\n                console.warn(`An error occured within custom function for ${componentKey}`, err);\n            }\n        }\n        else if (func) {\n            console.warn(`Unknown function type for ${componentKey}`);\n        }\n        return returnVal;\n    }\n    /**\n     * Execute a function.\n     *\n     * @param func\n     * @param args\n     * @returns\n     */\n    static execute(func, args, context = {}, options = {}) {\n        options = _.isObject(options) ? options : { noeval: options };\n        if (Evaluator.noeval || options.noeval) {\n            console.warn('No evaluations allowed for this renderer.');\n            return;\n        }\n        return Array.isArray(args) ? func.apply(context, args) : func.call(context, args);\n    }\n    ;\n}\nexports.BaseEvaluator = BaseEvaluator;\nBaseEvaluator.templateSettings = {\n    interpolate: /{{([\\s\\S]+?)}}/g,\n    evaluate: /\\{%([\\s\\S]+?)%\\}/g,\n    escape: /\\{\\{\\{([\\s\\S]+?)\\}\\}\\}/g\n};\nBaseEvaluator.noeval = false;\n// The extendable evaluator\nclass Evaluator extends BaseEvaluator {\n    /**\n     * Allow external modules the ability to extend the Evaluator.\n     * @param evaluator\n     */\n    static registerEvaluator(evaluator) {\n        Object.keys(evaluator).forEach((key) => {\n            Evaluator[key] = evaluator[key];\n        });\n    }\n}\nexports.Evaluator = Evaluator;\n\n\n//# sourceURL=webpack://@formio/core/./src/utils/Evaluator.ts?");

/***/ }),

/***/ "./src/utils/date.ts":
/*!***************************!*\
  !*** ./src/utils/date.ts ***!
  \***************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.dayjs = exports.getDateSetting = exports.formatDate = exports.momentDate = exports.convertFormatToMoment = exports.currentTimezone = void 0;\nconst dayjs_1 = __importDefault(__webpack_require__(/*! dayjs */ \"./node_modules/dayjs/dayjs.min.js\"));\nexports.dayjs = dayjs_1.default;\nconst timezone_1 = __importDefault(__webpack_require__(/*! dayjs/plugin/timezone */ \"./node_modules/dayjs/plugin/timezone.js\"));\nconst utc_1 = __importDefault(__webpack_require__(/*! dayjs/plugin/utc */ \"./node_modules/dayjs/plugin/utc.js\"));\nconst lodash_1 = __webpack_require__(/*! @formio/lodash */ \"./node_modules/@formio/lodash/lib/index.js\");\nconst Evaluator_1 = __webpack_require__(/*! ./Evaluator */ \"./src/utils/Evaluator.ts\");\ndayjs_1.default.extend(utc_1.default);\ndayjs_1.default.extend(timezone_1.default);\n/**\n * Get the current timezone string.\n *\n * @return {string}\n */\nfunction currentTimezone() {\n    return dayjs_1.default.tz.guess();\n}\nexports.currentTimezone = currentTimezone;\n/**\n * Convert the format from the angular-datepicker module to moment format.\n * @param format\n * @return {string}\n */\nfunction convertFormatToMoment(format) {\n    return format\n        // Year conversion.\n        .replace(/y/g, 'Y')\n        // Day in month.\n        .replace(/d/g, 'D')\n        // Day in week.\n        .replace(/E/g, 'd')\n        // AM/PM marker\n        .replace(/a/g, 'A')\n        // Unix Timestamp\n        .replace(/U/g, 'X');\n}\nexports.convertFormatToMoment = convertFormatToMoment;\n/**\n * Get the moment date object for translating dates with timezones.\n *\n * @param value\n * @param format\n * @param timezone\n * @return {*}\n */\nfunction momentDate(value, format, timezone) {\n    const momentDate = (0, dayjs_1.default)(value);\n    if (timezone === 'UTC') {\n        return dayjs_1.default.utc();\n    }\n    if (timezone !== currentTimezone() || (format && format.match(/\\s(z$|z\\s)/))) {\n        return momentDate.tz(timezone);\n    }\n    return momentDate;\n}\nexports.momentDate = momentDate;\n/**\n * Format a date provided a value, format, and timezone object.\n *\n * @param value\n * @param format\n * @param timezone\n * @return {string}\n */\nfunction formatDate(value, format, timezone) {\n    const momentDate = (0, dayjs_1.default)(value);\n    if (timezone === 'UTC') {\n        return `${dayjs_1.default.utc().format(convertFormatToMoment(format))} UTC`;\n    }\n    if (timezone) {\n        return momentDate.tz(timezone).format(`${convertFormatToMoment(format)} z`);\n    }\n    return momentDate.format(convertFormatToMoment(format));\n}\nexports.formatDate = formatDate;\n/**\n * Return a translated date setting.\n *\n * @param date\n * @return {(null|Date)}\n */\nfunction getDateSetting(date) {\n    if ((0, lodash_1.isNil)(date) || (0, lodash_1.isNaN)(date) || date === '') {\n        return null;\n    }\n    if (date instanceof Date) {\n        return date;\n    }\n    else if (typeof date.toDate === 'function') {\n        return date.isValid() ? date.toDate() : null;\n    }\n    let dateSetting = ((typeof date !== 'string') || (date.indexOf('moment(') === -1)) ? (0, dayjs_1.default)(date) : null;\n    if (dateSetting && dateSetting.isValid()) {\n        return dateSetting.toDate();\n    }\n    dateSetting = null;\n    try {\n        const value = Evaluator_1.Evaluator.evaluator(`return ${date};`, 'moment')(dayjs_1.default);\n        if (typeof value === 'string') {\n            dateSetting = (0, dayjs_1.default)(value);\n        }\n        else if (typeof value.toDate === 'function') {\n            dateSetting = (0, dayjs_1.default)(value.toDate().toUTCString());\n        }\n        else if (value instanceof Date) {\n            dateSetting = (0, dayjs_1.default)(value);\n        }\n    }\n    catch (e) {\n        return null;\n    }\n    if (!dateSetting) {\n        return null;\n    }\n    // Ensure this is a date.\n    if (!dateSetting.isValid()) {\n        return null;\n    }\n    return dateSetting.toDate();\n}\nexports.getDateSetting = getDateSetting;\n\n\n//# sourceURL=webpack://@formio/core/./src/utils/date.ts?");

/***/ }),

/***/ "./src/utils/dom.ts":
/*!**************************!*\
  !*** ./src/utils/dom.ts ***!
  \**************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.empty = exports.removeChildFrom = exports.prependTo = exports.appendTo = void 0;\n/**\n * Append an HTML DOM element to a container.\n *\n * @param element\n * @param container\n */\nfunction appendTo(element, container) {\n    if (container && element) {\n        container === null || container === void 0 ? void 0 : container.appendChild(element);\n    }\n}\nexports.appendTo = appendTo;\n/**\n * Prepend an HTML DOM element to a container.\n *\n * @param {HTMLElement} element - The DOM element to prepend.\n * @param {HTMLElement} container - The DOM element that is the container of the element getting prepended.\n */\nfunction prependTo(element, container) {\n    if (container && element) {\n        if (container.firstChild) {\n            try {\n                container.insertBefore(element, container.firstChild);\n            }\n            catch (err) {\n                console.warn(err);\n                container.appendChild(element);\n            }\n        }\n        else {\n            container.appendChild(element);\n        }\n    }\n}\nexports.prependTo = prependTo;\n/**\n * Removes an HTML DOM element from its bounding container.\n *\n * @param {HTMLElement} element - The element to remove.\n * @param {HTMLElement} container - The DOM element that is the container of the element to remove.\n */\nfunction removeChildFrom(element, container) {\n    if (container && element && container.contains(element)) {\n        try {\n            container.removeChild(element);\n        }\n        catch (err) {\n            console.warn(err);\n        }\n    }\n}\nexports.removeChildFrom = removeChildFrom;\n/**\n * Empty's an HTML DOM element.\n *\n * @param {HTMLElement} element - The element you wish to empty.\n */\nfunction empty(element) {\n    if (element) {\n        while (element.firstChild) {\n            element.removeChild(element.firstChild);\n        }\n    }\n}\nexports.empty = empty;\n\n\n//# sourceURL=webpack://@formio/core/./src/utils/dom.ts?");

/***/ }),

/***/ "./src/utils/formUtil.ts":
/*!*******************************!*\
  !*** ./src/utils/formUtil.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.uniqueName = exports.guid = exports.flattenComponents = exports.eachComponent = void 0;\nconst Evaluator_1 = __webpack_require__(/*! ./Evaluator */ \"./src/utils/Evaluator.ts\");\nconst lodash_1 = __webpack_require__(/*! @formio/lodash */ \"./node_modules/@formio/lodash/lib/index.js\");\n/**\n * Iterate through each component within a form.\n *\n * @param {Object} components\n *   The components to iterate.\n * @param {Function} fn\n *   The iteration function to invoke for each component.\n * @param {Boolean} includeAll\n *   Whether or not to include layout components.\n * @param {String} path\n *   The current data path of the element. Example: data.user.firstName\n * @param {Object} parent\n *   The parent object.\n */\nfunction eachComponent(components, fn, includeAll, path, parent) {\n    if (!components)\n        return;\n    path = path || '';\n    components.forEach((component) => {\n        if (!component) {\n            return;\n        }\n        const hasColumns = component.columns && Array.isArray(component.columns);\n        const hasRows = component.rows && Array.isArray(component.rows);\n        const hasComps = component.components && Array.isArray(component.components);\n        let noRecurse = false;\n        const newPath = component.key ? (path ? (`${path}.${component.key}`) : component.key) : '';\n        // Keep track of parent references.\n        if (parent) {\n            // Ensure we don't create infinite JSON structures.\n            component.parent = Object.assign({}, parent);\n            delete component.parent.components;\n            delete component.parent.componentMap;\n            delete component.parent.columns;\n            delete component.parent.rows;\n        }\n        // there's no need to add other layout components here because we expect that those would either have columns, rows or components\n        const layoutTypes = ['htmlelement', 'content'];\n        const isLayoutComponent = hasColumns || hasRows || hasComps || layoutTypes.indexOf(component.type) > -1;\n        if (includeAll || component.tree || !isLayoutComponent) {\n            noRecurse = fn(component, newPath, components);\n        }\n        const subPath = () => {\n            if (component.key &&\n                !['panel', 'table', 'well', 'columns', 'fieldset', 'tabs', 'form'].includes(component.type) &&\n                (['datagrid', 'container', 'editgrid', 'address', 'dynamicWizard'].includes(component.type) ||\n                    component.tree)) {\n                return newPath;\n            }\n            else if (component.key &&\n                component.type === 'form') {\n                return `${newPath}.data`;\n            }\n            return path;\n        };\n        if (!noRecurse) {\n            if (hasColumns) {\n                component.columns.forEach((column) => eachComponent(column.components, fn, includeAll, subPath(), parent ? component : null));\n            }\n            else if (hasRows) {\n                component.rows.forEach((row) => {\n                    if (Array.isArray(row)) {\n                        row.forEach((column) => eachComponent(column.components, fn, includeAll, subPath(), parent ? component : null));\n                    }\n                });\n            }\n            else if (hasComps) {\n                eachComponent(component.components, fn, includeAll, subPath(), parent ? component : null);\n            }\n        }\n    });\n}\nexports.eachComponent = eachComponent;\n/**\n * Flatten the form components for data manipulation.\n *\n * @param {Object} components\n *   The components to iterate.\n * @param {Boolean} includeAll\n *   Whether or not to include layout components.\n *\n * @returns {Object}\n *   The flattened components map.\n */\nfunction flattenComponents(components, includeAll) {\n    const flattened = {};\n    eachComponent(components, (component, path) => {\n        flattened[path] = component;\n    }, includeAll);\n    return flattened;\n}\nexports.flattenComponents = flattenComponents;\nfunction guid() {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n        const r = Math.random() * 16 | 0;\n        const v = c === 'x'\n            ? r\n            : (r & 0x3 | 0x8);\n        return v.toString(16);\n    });\n}\nexports.guid = guid;\n/**\n * Make a filename guaranteed to be unique.\n * @param name\n * @param template\n * @param evalContext\n * @returns {string}\n */\nfunction uniqueName(name, template, evalContext) {\n    template = template || '{{fileName}}-{{guid}}';\n    //include guid in template anyway, to prevent overwriting issue if filename matches existing file\n    if (!template.includes('{{guid}}')) {\n        template = `${template}-{{guid}}`;\n    }\n    const parts = name.split('.');\n    let fileName = parts.slice(0, parts.length - 1).join('.');\n    const extension = parts.length > 1\n        ? `.${(0, lodash_1.last)(parts)}`\n        : '';\n    //allow only 100 characters from original name to avoid issues with filename length restrictions\n    fileName = fileName.substr(0, 100);\n    evalContext = Object.assign(evalContext || {}, {\n        fileName,\n        guid: guid()\n    });\n    //only letters, numbers, dots, dashes, underscores and spaces are allowed. Anything else will be replaced with dash\n    const uniqueName = `${Evaluator_1.Evaluator.interpolate(template, evalContext)}${extension}`.replace(/[^0-9a-zA-Z.\\-_ ]/g, '-');\n    return uniqueName;\n}\nexports.uniqueName = uniqueName;\n\n\n//# sourceURL=webpack://@formio/core/./src/utils/formUtil.ts?");

/***/ }),

/***/ "./src/utils/index.ts":
/*!****************************!*\
  !*** ./src/utils/index.ts ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.dom = exports.unwind = exports.override = exports.sanitize = exports.BaseEvaluator = exports.Evaluator = exports.Utils = void 0;\nexports.Utils = __importStar(__webpack_require__(/*! ./formUtil */ \"./src/utils/formUtil.ts\"));\nvar Evaluator_1 = __webpack_require__(/*! ./Evaluator */ \"./src/utils/Evaluator.ts\");\nObject.defineProperty(exports, \"Evaluator\", ({ enumerable: true, get: function () { return Evaluator_1.Evaluator; } }));\nObject.defineProperty(exports, \"BaseEvaluator\", ({ enumerable: true, get: function () { return Evaluator_1.BaseEvaluator; } }));\nvar sanitize_1 = __webpack_require__(/*! ./sanitize */ \"./src/utils/sanitize.ts\");\nObject.defineProperty(exports, \"sanitize\", ({ enumerable: true, get: function () { return sanitize_1.sanitize; } }));\nvar override_1 = __webpack_require__(/*! ./override */ \"./src/utils/override.ts\");\nObject.defineProperty(exports, \"override\", ({ enumerable: true, get: function () { return override_1.override; } }));\nvar unwind_1 = __webpack_require__(/*! ./unwind */ \"./src/utils/unwind.ts\");\nObject.defineProperty(exports, \"unwind\", ({ enumerable: true, get: function () { return unwind_1.unwind; } }));\nexports.dom = __importStar(__webpack_require__(/*! ./dom */ \"./src/utils/dom.ts\"));\n__exportStar(__webpack_require__(/*! ./utils */ \"./src/utils/utils.ts\"), exports);\n__exportStar(__webpack_require__(/*! ./date */ \"./src/utils/date.ts\"), exports);\n__exportStar(__webpack_require__(/*! ./mask */ \"./src/utils/mask.ts\"), exports);\n\n\n//# sourceURL=webpack://@formio/core/./src/utils/index.ts?");

/***/ }),

/***/ "./src/utils/mask.ts":
/*!***************************!*\
  !*** ./src/utils/mask.ts ***!
  \***************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.matchInputMask = exports.getInputMask = void 0;\nconst lodash_1 = __webpack_require__(/*! @formio/lodash */ \"./node_modules/@formio/lodash/lib/index.js\");\n/**\n * Returns an input mask that is compatible with the input mask library.\n * @param {string} mask - The Form.io input mask.\n * @param {string} placeholderChar - Char which is used as a placeholder.\n * @returns {Array} - The input mask for the mask library.\n */\nfunction getInputMask(mask, placeholderChar) {\n    if (mask instanceof Array) {\n        return mask;\n    }\n    const maskArray = [];\n    maskArray.numeric = true;\n    for (let i = 0; i < mask.length; i++) {\n        switch (mask[i]) {\n            case '9':\n                maskArray.push(/\\d/);\n                break;\n            case 'A':\n                maskArray.numeric = false;\n                maskArray.push(/[a-zA-Z]/);\n                break;\n            case 'a':\n                maskArray.numeric = false;\n                maskArray.push(/[a-z]/);\n                break;\n            case '*':\n                maskArray.numeric = false;\n                maskArray.push(/[a-zA-Z0-9]/);\n                break;\n            // If char which is used inside mask placeholder was used in the mask, replace it with space to prevent errors\n            case placeholderChar:\n                maskArray.numeric = false;\n                maskArray.push(' ');\n                break;\n            default:\n                maskArray.numeric = false;\n                maskArray.push(mask[i]);\n                break;\n        }\n    }\n    return maskArray;\n}\nexports.getInputMask = getInputMask;\nfunction matchInputMask(value, inputMask) {\n    if (!inputMask) {\n        return true;\n    }\n    // If value is longer than mask, it isn't valid.\n    if (value.length > inputMask.length) {\n        return false;\n    }\n    for (let i = 0; i < inputMask.length; i++) {\n        const char = value[i];\n        const charPart = inputMask[i];\n        if (!((0, lodash_1.isRegExp)(charPart) && charPart.test(char) || charPart === char)) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.matchInputMask = matchInputMask;\n\n\n//# sourceURL=webpack://@formio/core/./src/utils/mask.ts?");

/***/ }),

/***/ "./src/utils/override.ts":
/*!*******************************!*\
  !*** ./src/utils/override.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.override = void 0;\n/**\n * Simple class to allow for overriding base classes.\n * @param classObj\n * @param extenders\n */\nfunction override(classObj, extenders) {\n    for (let key in extenders) {\n        if (extenders.hasOwnProperty(key)) {\n            const extender = extenders[key];\n            if (typeof extender === 'function') {\n                classObj.prototype[key] = extender;\n            }\n            else {\n                const prop = Object.getOwnPropertyDescriptor(classObj.prototype, key);\n                for (let attr in extender) {\n                    if (extender.hasOwnProperty(attr)) {\n                        prop[attr] = extender[attr](prop[attr]);\n                    }\n                }\n                Object.defineProperty(classObj.prototype, key, prop);\n            }\n        }\n    }\n}\nexports.override = override;\n\n\n//# sourceURL=webpack://@formio/core/./src/utils/override.ts?");

/***/ }),

/***/ "./src/utils/sanitize.ts":
/*!*******************************!*\
  !*** ./src/utils/sanitize.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.sanitize = void 0;\nconst dompurify_1 = __importDefault(__webpack_require__(/*! dompurify */ \"./node_modules/dompurify/dist/purify.js\"));\nlet DOMPurify = null;\nconst getDOMPurify = () => {\n    if (DOMPurify) {\n        return DOMPurify;\n    }\n    if (window) {\n        DOMPurify = (0, dompurify_1.default)(window);\n        return DOMPurify;\n    }\n    return null;\n};\n/**\n * Sanitize an html string.\n *\n * @param string\n * @returns {*}\n */\nfunction sanitize(string, options) {\n    const dompurify = getDOMPurify();\n    if (!dompurify) {\n        console.log('DOMPurify unable to sanitize the contents.');\n        return string;\n    }\n    // Dompurify configuration\n    const sanitizeOptions = {\n        ADD_ATTR: ['ref', 'target', 'within'],\n        USE_PROFILES: { html: true }\n    };\n    // Add attrs\n    if (options.sanitizeConfig && Array.isArray(options.sanitizeConfig.addAttr) && options.sanitizeConfig.addAttr.length > 0) {\n        options.sanitizeConfig.addAttr.forEach((attr) => {\n            sanitizeOptions.ADD_ATTR.push(attr);\n        });\n    }\n    // Add tags\n    if (options.sanitizeConfig && Array.isArray(options.sanitizeConfig.addTags) && options.sanitizeConfig.addTags.length > 0) {\n        sanitizeOptions.ADD_TAGS = options.sanitizeConfig.addTags;\n    }\n    // Allow tags\n    if (options.sanitizeConfig && Array.isArray(options.sanitizeConfig.allowedTags) && options.sanitizeConfig.allowedTags.length > 0) {\n        sanitizeOptions.ALLOWED_TAGS = options.sanitizeConfig.allowedTags;\n    }\n    // Allow attributes\n    if (options.sanitizeConfig && Array.isArray(options.sanitizeConfig.allowedAttrs) && options.sanitizeConfig.allowedAttrs.length > 0) {\n        sanitizeOptions.ALLOWED_ATTR = options.sanitizeConfig.allowedAttrs;\n    }\n    // Allowd URI Regex\n    if (options.sanitizeConfig && options.sanitizeConfig.allowedUriRegex) {\n        sanitizeOptions.ALLOWED_URI_REGEXP = options.sanitizeConfig.allowedUriRegex;\n    }\n    // Allow to extend the existing array of elements that are safe for URI-like values\n    if (options.sanitizeConfig && Array.isArray(options.sanitizeConfig.addUriSafeAttr) && options.sanitizeConfig.addUriSafeAttr.length > 0) {\n        sanitizeOptions.ADD_URI_SAFE_ATTR = options.sanitizeConfig.addUriSafeAttr;\n    }\n    return dompurify.sanitize(string, sanitizeOptions);\n}\nexports.sanitize = sanitize;\n\n\n//# sourceURL=webpack://@formio/core/./src/utils/sanitize.ts?");

/***/ }),

/***/ "./src/utils/unwind.ts":
/*!*****************************!*\
  !*** ./src/utils/unwind.ts ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.unwind = exports.rewind = exports.mergeArray = exports.mergeObject = void 0;\nconst lodash_1 = __webpack_require__(/*! @formio/lodash */ \"./node_modules/@formio/lodash/lib/index.js\");\nconst formUtil_1 = __webpack_require__(/*! ./formUtil */ \"./src/utils/formUtil.ts\");\nfunction mergeObject(src, dst) {\n    (0, lodash_1.each)(src, function (value, key) {\n        if (!Array.isArray(value)) {\n            dst[key] = value;\n        }\n        else {\n            if (!dst[key]) {\n                dst[key] = [];\n            }\n            mergeArray(value, dst[key]);\n        }\n    });\n}\nexports.mergeObject = mergeObject;\nfunction mergeArray(src, dst) {\n    src.forEach(function (value) {\n        var query = {};\n        (0, lodash_1.each)(value, function (subValue, key) {\n            if (!Array.isArray(subValue)) {\n                query[key] = subValue;\n            }\n        });\n        var dstValue = (0, lodash_1.find)(dst, query);\n        if (dstValue) {\n            mergeObject(value, dstValue);\n        }\n        else {\n            dst.push(value);\n        }\n    });\n}\nexports.mergeArray = mergeArray;\nfunction rewind(submissions) {\n    var submission = { data: {} };\n    if (submissions && submissions.length) {\n        submissions.forEach((sub) => mergeObject(sub.data, submission.data));\n    }\n    return submission;\n}\nexports.rewind = rewind;\nfunction unwind(form, submission) {\n    var dataPaths = {};\n    var locked = {};\n    var submissions = [(0, lodash_1.fastCloneDeep)(submission)];\n    // Set the data value for a data path.\n    /* eslint-disable no-use-before-define */\n    var setDataValue = function (dataPath, values, parent, offset, current) {\n        offset = offset || 0;\n        current = current || 0;\n        // Make sure we don't overwrite any locked values.\n        while ((0, lodash_1.has)(locked, \"[\" + current + \"].\" + parent)) {\n            if ((current + 1) >= submissions.length) {\n                submissions.push((0, lodash_1.fastCloneDeep)(submissions[current]));\n            }\n            current++;\n        }\n        // Ensure that all parents have been copied over to this path.\n        /* eslint-disable no-useless-escape */\n        var parentPath = parent.replace(/\\.[^\\.]+$/, '');\n        if (!(0, lodash_1.has)(submissions[current].data, parentPath) &&\n            submissions[current - 1] &&\n            (0, lodash_1.has)(submissions[(current - 1)].data, parentPath)) {\n            (0, lodash_1.set)(submissions[current].data, parentPath, (0, lodash_1.fastCloneDeep)((0, lodash_1.get)(submissions[(current - 1)].data, parentPath)));\n        }\n        /* eslint-enable no-useless-escape */\n        var pathValue = [];\n        (0, lodash_1.set)(submissions[current].data, parent, pathValue);\n        (0, lodash_1.set)(locked, \"[\" + current + \"].\" + parent, true);\n        for (var i = offset; i < values.length; i++) {\n            if ((i - offset) <= dataPath.max) {\n                pathValue.push(values[i]);\n                if (dataPath.paths && Object.keys(dataPath.paths).length) {\n                    addData(dataPath.paths, values[i], parent + \"[\" + (i - offset) + \"]\", current);\n                }\n            }\n            else {\n                setDataValue(dataPath, values, parent, i, current);\n                break;\n            }\n        }\n    };\n    /* eslint-enable no-use-before-define */\n    // Add data to a series of data paths.\n    var addData = function (dataPaths, data, parent, current) {\n        for (var path in dataPaths) {\n            var dataPath = dataPaths[path];\n            if (data[path] && Array.isArray(data[path])) {\n                setDataValue(dataPath, data[path], (parent ? parent + \".\" + path : path), 0, current);\n            }\n        }\n    };\n    var addDataPaths = function (dataPath, paths, index, parentDataPath) {\n        index = index || 0;\n        var path = paths[index];\n        /* eslint-disable no-useless-escape */\n        var matches = path.match(/([^\\[]+)\\[?([0-9]+)?\\]?/);\n        /* eslint-enable no-useless-escape */\n        if (matches && (matches.length === 3)) {\n            var dataParam = matches[1];\n            var dataIndex = parseInt(matches[2], 10) || 0;\n            if (dataPath[dataParam]) {\n                if (dataIndex > dataPath[dataParam].max) {\n                    dataPath[dataParam].max = dataIndex;\n                }\n            }\n            else {\n                dataPath[dataParam] = {\n                    max: dataIndex,\n                    param: dataParam,\n                    parent: parentDataPath || null,\n                    paths: {}\n                };\n            }\n            if ((index + 1) < paths.length) {\n                addDataPaths(dataPath[dataParam].paths, paths, (index + 1), dataPath[dataParam]);\n            }\n        }\n    };\n    // Iterate through all components.\n    (0, formUtil_1.eachComponent)(form.components, function (component, path) {\n        var _a;\n        if (component.type === 'form' && ((_a = component.components) === null || _a === void 0 ? void 0 : _a.length)) {\n            (0, formUtil_1.eachComponent)(component.components, (comp) => {\n                comp.isInsideNestedForm = true;\n            });\n        }\n        if (!component.overlay || (!component.overlay.width && !component.overlay.height)) {\n            return;\n        }\n        var hasDataPath = component.properties && component.properties.dataPath;\n        var key = component.key;\n        if (hasDataPath) {\n            path = component.properties.dataPath;\n            key = component.properties.dataPath;\n        }\n        /* eslint-disable no-useless-escape */\n        var paths = (0, lodash_1.filter)(path.replace(new RegExp(\".?\" + component.key + \"$\"), '').split('.'));\n        /* eslint-enable no-useless-escape */\n        if (!hasDataPath && paths.length && !component.isInsideNestedForm) {\n            key = paths.map(function (subpath) { return subpath + \"[0]\"; }).join('.') + \".\" + component.key;\n        }\n        if (component.multiple) {\n            paths.push(component.key);\n        }\n        component.key = key;\n        if (paths && paths.length) {\n            addDataPaths(dataPaths, paths);\n        }\n    }, true);\n    addData(dataPaths, submission.data);\n    return submissions;\n}\nexports.unwind = unwind;\n\n\n//# sourceURL=webpack://@formio/core/./src/utils/unwind.ts?");

/***/ }),

/***/ "./src/utils/utils.ts":
/*!****************************!*\
  !*** ./src/utils/utils.ts ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.boolValue = exports.escapeRegExCharacters = void 0;\nconst _ = __importStar(__webpack_require__(/*! @formio/lodash */ \"./node_modules/@formio/lodash/lib/index.js\"));\n/**\n * Escapes RegEx characters in provided String value.\n *\n * @param {String} value\n *   String for escaping RegEx characters.\n * @returns {string}\n *   String with escaped RegEx characters.\n */\nfunction escapeRegExCharacters(value) {\n    return value.replace(/[-[\\]/{}()*+?.\\\\^$|]/g, '\\\\$&');\n}\nexports.escapeRegExCharacters = escapeRegExCharacters;\n/**\n * Determines the boolean value of a setting.\n *\n * @param value\n * @return {boolean}\n */\nfunction boolValue(value) {\n    if (_.isBoolean(value)) {\n        return value;\n    }\n    else if (_.isString(value)) {\n        return (value.toLowerCase() === 'true');\n    }\n    else {\n        return !!value;\n    }\n}\nexports.boolValue = boolValue;\n\n\n//# sourceURL=webpack://@formio/core/./src/utils/utils.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/utils/index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});